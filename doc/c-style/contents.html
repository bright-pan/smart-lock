<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Google 开源项目风格指南</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="None" href="contents.html#document-index" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="contents.html#document-index">
          <span>Google 开源项目风格指南</span></a></h1>
        <h2 class="heading"><span>Google 开源项目风格指南</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="contents.html#document-contents">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="contents">
<span id="id1"></span><h1>内容目录</h1>
<div class="toctree-wrapper compound">
<span id="document-index"></span><div class="section" id="google">
<h2>Google 开源项目风格指南 (中文版)</h2>
<ul class="simple">
<li>在线文档托管在 ReadTheDocs : <a class="reference external" href="http://zh-google-styleguide.readthedocs.org/">在线阅读最新版本</a></li>
<li>中文风格指南 GitHub 托管地址：`zh-google-styleguide &lt;<a class="reference external" href="https://github.com/zh-google-styleguide/zh-google-styleguide">https://github.com/zh-google-styleguide/zh-google-styleguide</a>&gt;`_</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>声明.</p>
<p>本项目并非 Google 官方项目, 而是由国内程序员凭热情创建和维护.</p>
<p class="last">如果你关注的是 Google 官方英文版, 请移步 <a class="reference external" href="http://code.google.com/p/google-styleguide/">Google Style Guide</a></p>
</div>
<p>每个较大的开源项目都有自己的风格指南: 关于如何为该项目编写代码的一系列约定 (有时候会比较武断).
当所有代码均保持一致的风格, 在理解大型代码库时更为轻松.</p>
<p>&#8220;风格&#8221; 的含义涵盖范围广, 从 &#8220;变量使用驼峰格式 (camelCase)&#8221; 到 &#8220;决不使用全局变量&#8221; 再到 &#8220;决不使用异常&#8221;.
英文版项目维护的是在 Google 使用的编程风格指南. 如果你正在修改的项目源自 Google, 你可能会被引导至
英文版项目页面, 以了解项目所使用的风格.</p>
<p>我们已经发布了四份 <strong>中文版</strong> 的风格指南:</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/">Google C++ 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/">Google Objective-C 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/">Google Python 风格指南</a></li>
<li><a class="reference external" href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md">Google JSON 风格指南</a></li>
</ol>
<p>中文版项目采用 reStructuredText 纯文本标记语法, 并使用 Sphinx 生成 HTML / CHM / PDF 等文档格式.</p>
<ul class="simple">
<li>英文版项目还包含 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/cpplint">cpplint</a> - 一个用来帮助适应风格准则的工具, 以及 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el">google-c-style.el</a>, Google 风格的 Emacs 配置文件.</li>
<li>另外, 招募自愿者翻译 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml">JavaScript Style Guide</a> 以及 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/xmlstyle.html">XML Document Format Style Guide</a>, 有意者请联系 <a class="reference external" href="http://yangyubo.com">brantyoung</a>.</li>
</ul>
</div>
<span id="document-google-cpp-styleguide/contents"></span><div class="section" id="c">
<span id="cpp-contents"></span><h2>C++ 风格指南 - 内容目录</h2>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#c" id="id1">C++ 风格指南 - 内容目录</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<span id="document-google-cpp-styleguide/index"></span><div class="section" id="id1">
<h3>0. 扉页</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">3.133</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Benjy Weinberger</div>
<div class="line">Craig Silverstein</div>
<div class="line">Gregory Eitzmann</div>
<div class="line">Mark Mentovai</div>
<div class="line">Tashana Landray</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://www.yulefox.com">YuleFox</a></div>
<div class="line"><a class="reference external" href="http://yangyubo.com">brantyoung</a></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="http://google-styleguide.googlecode.com">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="id2">
<h4>0.1 译者前言</h4>
<p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码. 但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交这造成不小的困扰. Google 因此发布了这份自己的编程风格, 使所有提交代码的人都能获知 Google 的编程风格.</p>
<dl class="docutils">
<dt>翻译初衷:</dt>
<dd><p class="first">规则的作用就是避免混乱. 但规则本身一定要权威, 有说服力, 并且是理性的. 我们所见过的大部分编程规范, 其内容或不够严谨, 或阐述过于简单, 或带有一定的武断性.</p>
<p>Google 保持其一贯的严谨精神, 5 万汉字的指南涉及广泛, 论证严密. 我们翻译该系列指南的主因也正是其严谨性. 严谨意味着指南的价值不仅仅局限于它罗列出的规范, 更具参考意义的是它为了列出规范而做的谨慎权衡过程.</p>
<p>指南不仅列出你要怎么做, 还告诉你为什么要这么做, 哪些情况下可以不这么做, 以及如何权衡其利弊. 其他团队未必要完全遵照指南亦步亦趋, 如前面所说, 这份指南是 Google 根据自身实际情况打造的, 适用于其主导的开源项目. 其他团队可以参照该指南, 或从中汲取灵感, 建立适合自身实际情况的规范.</p>
<p class="last">我们在翻译的过程中, 收获颇多. 希望本系列指南中文版对你同样能有所帮助.</p>
</dd>
</dl>
<p>我们翻译时也是尽力保持严谨, 但水平所限, bug 在所难免. 有任何意见或建议, 可与我们取得联系.</p>
<p>中文版和英文版一样, 使用 <tt class="docutils literal"><span class="pre">Artistic</span> <span class="pre">License/GPL</span></tt> 开源许可.</p>
<dl class="docutils">
<dt>中文版修订历史:</dt>
<dd><ul class="first last">
<li><p class="first">2009-06 3.133 : YuleFox 的 1.0 版已经相当完善, 但原版在近一年的时间里, 其规范也发生了一些变化.</p>
<blockquote>
<div><p>brantyoung 与 YuleFox 一拍即合, 以项目的形式来延续中文版 : <a class="reference external" href="http://github.com/brantyoung/zh-google-styleguide">Google 开源项目风格指南 - 中文版项目</a>.</p>
<p>主要变化是同步到 3.133 最新英文版本, 做部分勘误和改善可读性方面的修改, 并改进排版效果. brantyoung 重新翻修, YuleFox 做后续评审.</p>
</div></blockquote>
</li>
<li><p class="first">2008-07 1.0 : 出自 <a class="reference external" href="http://www.yulefox.com/?p=207">YuleFox 的 Blog</a>, 很多地方摘录的也是该版本.</p>
</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id4">
<h4>0.2 背景</h4>
<p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p>
<p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 高效使用 C++ 的语言特性.</p>
<p><em>风格</em>, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 &#8220;风格&#8221; 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p>
<p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 &#8220;模式匹配&#8221; 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p>
<p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p>
<p>Google 主导的开源项目均符合本指南的规定.</p>
<p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p>
</div>
</div>
<span id="document-google-cpp-styleguide/headers"></span><div class="section" id="id1">
<h3>1. 头文件</h3>
<p>通常每一个 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件都有一个对应的 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件. 也有一些常见例外, 如单元测试代码和只包含 <tt class="docutils literal"><span class="pre">main()</span></tt> 函数的 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件.</p>
<p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p>
<p>下面的规则将引导你规避使用头文件时的各种陷阱.</p>
<div class="section" id="define">
<span id="define-guard"></span><h4>1.1. #define 保护</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所有头文件都应该使用 <tt class="docutils literal"><span class="pre">#define</span></tt> 防止头文件被多重包含, 命名格式当是: <tt class="docutils literal"><span class="pre">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span></tt></p>
</div>
<p>为保证唯一性, 头文件的命名应该依据所在项目源代码树的全路径. 例如, 项目 <tt class="docutils literal"><span class="pre">foo</span></tt> 中的头文件 <tt class="docutils literal"><span class="pre">foo/src/bar/baz.h</span></tt> 可按如下方式保护:</p>
<div class="highlight-c++"><pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
…
#endif // FOO_BAR_BAZ_H_</pre>
</div>
</div>
<div class="section" id="id2">
<h4>1.2. 头文件依赖</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">能用前置声明的地方尽量不使用 <tt class="docutils literal"><span class="pre">#include</span></tt>.</p>
</div>
<p>当一个头文件被包含的同时也引入了新的依赖, 一旦该头文件被修改, 代码就会被重新编译. 如果这个头文件又包含了其他头文件, 这些头文件的任何改变都将导致所有包含了该头文件的代码被重新编译. 因此, 我们倾向于减少包含头文件, 尤其是在头文件中包含头文件.</p>
<p>使用前置声明可以显著减少需要包含的头文件数量. 举例说明: 如果头文件中用到类 <tt class="docutils literal"><span class="pre">File</span></tt>, 但不需要访问 <tt class="docutils literal"><span class="pre">File</span></tt> 类的声明, 头文件中只需前置声明 <tt class="docutils literal"><span class="pre">class</span> <span class="pre">File;</span></tt> 而无须 <tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;file/base/file.h&quot;</span></tt>.</p>
<p>不允许访问类的定义的前提下, 我们在一个头文件中能对类 <tt class="docutils literal"><span class="pre">Foo</span></tt> 做哪些操作?</p>
<ul class="simple">
<li>我们可以将数据成员类型声明为 <tt class="docutils literal"><span class="pre">Foo</span> <span class="pre">*</span></tt> 或 <tt class="docutils literal"><span class="pre">Foo</span> <span class="pre">&amp;</span></tt>.</li>
<li>我们可以将函数参数 / 返回值的类型声明为 <tt class="docutils literal"><span class="pre">Foo</span></tt> (但不能定义实现).</li>
<li>我们可以将静态数据成员的类型声明为 <tt class="docutils literal"><span class="pre">Foo</span></tt>, 因为静态数据成员的定义在类定义之外.</li>
</ul>
<p>反之, 如果你的类是 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的子类, 或者含有类型为 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的非静态数据成员, 则必须包含 <tt class="docutils literal"><span class="pre">Foo</span></tt> 所在的头文件.</p>
<p>有时, 使用指针成员 (如果是 <tt class="docutils literal"><span class="pre">scoped_ptr</span></tt> 更好) 替代对象成员的确是明智之选. 然而, 这会降低代码可读性及执行效率, 因此如果仅仅为了少包含头文件，还是不要这么做的好.</p>
<p>当然 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件无论如何都需要所使用类的定义部分, 自然也就会包含若干头文件.</p>
</div>
<div class="section" id="inline-functions">
<span id="id3"></span><h4>1.3. 内联函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</dd>
<dt>优点:</dt>
<dd>当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</dd>
<dt>缺点:</dt>
<dd>滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</dd>
<dt>结论:</dt>
<dd><p class="first">一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<p>另一个实用的经验准则: 内联那些包含循环或 <tt class="docutils literal"><span class="pre">switch</span></tt> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <tt class="docutils literal"><span class="pre">switch</span></tt> 语句从不被执行).</p>
<p class="last">有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联.  通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
</dd>
</dl>
</div>
<div class="section" id="inl-h">
<span id="inl-files"></span><h4>1.4. -inl.h文件</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">复杂的内联函数的定义, 应放在后缀名为 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 的头文件中.</p>
</div>
<p>内联函数的定义必须放在头文件中, 编译器才能在调用点内联展开定义. 然而, 实现代码理论上应该放在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中, 我们不希望 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中有太多实现代码, 除非在可读性和性能上有明显优势.</p>
<p>如果内联函数的定义比较短小, 逻辑比较简单, 实现代码放在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件里没有任何问题. 比如, 存取函数的实现理所当然都应该放在类定义内. 出于编写者和调用者的方便, 较复杂的内联函数也可以放到 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中, 如果你觉得这样会使头文件显得笨重, 也可以把它萃取到单独的 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 中. 这样把实现和类定义分离开来, 当需要时包含对应的 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 即可。</p>
<p><tt class="docutils literal"><span class="pre">-inl.h</span></tt> 文件还可用于函数模板的定义. 从而增强模板定义的可读性.</p>
<p>别忘了 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 和其他头文件一样, 也需要 <tt class="docutils literal"><span class="pre">#define</span></tt> 保护.</p>
</div>
<div class="section" id="id4">
<h4>1.5. 函数参数的顺序</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">定义函数时, 参数顺序依次为: 输入参数, 然后是输出参数.</p>
</div>
<p>C/C++ 函数参数分为输入参数, 输出参数, 和输入/输出参数三种. 输入参数一般传值或传 <tt class="docutils literal"><span class="pre">const</span></tt> 引用, 输出参数或输入/输出参数则是非-<tt class="docutils literal"><span class="pre">const</span></tt> 指针. 对参数排序时, 将只输入的参数放在所有输出参数之前. 尤其是不要仅仅因为是新加的参数, 就把它放在最后; 即使是新加的只输入参数也要放在输出参数之前.</p>
<p>这条规则并不需要严格遵守. 输入/输出两用参数 (通常是类/结构体变量) 把事情变得复杂, 为保持和相关函数的一致性, 你有时不得不有所变通.</p>
</div>
<div class="section" id="include">
<h4>1.6. <tt class="docutils literal"><span class="pre">#include</span></tt> 的路径及顺序</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: C 库, C++ 库, 其他库的 <cite>.h</cite>, 本项目内的 <cite>.h</cite>.</p>
</div>
<dl class="docutils">
<dt>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <tt class="docutils literal"><span class="pre">.</span></tt> (当前目录) 或 <tt class="docutils literal"><span class="pre">..</span></tt> (上级目录). 例如, <tt class="docutils literal"><span class="pre">google-awesome-project/src/base/logging.h</span></tt> 应该按如下方式包含:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="cp">#include “base/logging.h”</span>
</pre></div>
</div>
</dd>
<dt>又如, <tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 的主要作用是实现或测试 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 的功能, <tt class="docutils literal"><span class="pre">foo.cc</span></tt> 中包含头文件的次序如下:</dt>
<dd><ol class="first last arabic simple">
<li><tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件</li>
<li>本项目内 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件</li>
</ol>
</dd>
</dl>
<p>这种排序方式可有效减少隐藏依赖. 我们希望每一个头文件都是可被独立编译的 (yospaly 译注: 即该头文件本身已包含所有必要的显式依赖), 最简单的方法是将其作为第一个 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件 <tt class="docutils literal"><span class="pre">#included</span></tt> 进对应的 <tt class="docutils literal"><span class="pre">.cc</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 和 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 通常位于同一目录下 (如 <tt class="docutils literal"><span class="pre">base/basictypes_unittest.cc</span></tt> 和 <tt class="docutils literal"><span class="pre">base/basictypes.h</span></tt>), 但也可以放在不同目录下.</p>
<p>按字母顺序对头文件包含进行二次排序是不错的主意 (yospaly 译注: 之前已经按头文件类别排过序了).</p>
<dl class="docutils">
<dt>举例来说, <tt class="docutils literal"><span class="pre">google-awesome-project/src/foo/internal/fooserver.cc</span></tt> 的包含次序如下:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;foo/public/fooserver.h&quot; </span><span class="c1">// 优先位置</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;hash_map&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &quot;base/basictypes.h&quot;</span>
<span class="cp">#include &quot;base/commandlineflags.h&quot;</span>
<span class="cp">#include &quot;foo/public/bar.h&quot;</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>避免多重包含是学编程时最基本的要求;</li>
<li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li>
<li>内联函数的合理使用可提高代码执行效率;</li>
<li><tt class="docutils literal"><span class="pre">-inl.h</span></tt> 可提高代码可读性 (一般用不到吧:D);</li>
<li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li>
<li>包含文件的名称使用 <tt class="docutils literal"><span class="pre">.</span></tt> 和 <tt class="docutils literal"><span class="pre">..</span></tt> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 &#8220;最需要编译&#8221; (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/scoping"></span><div class="section" id="id1">
<h3>2. 作用域</h3>
<div class="section" id="namespaces">
<span id="id2"></span><h4>2.1. 名字空间</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">鼓励在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件内使用匿名名字空间. 使用具名的名字空间时, 其名称可基于项目名或相对路径. 不要使用 <em>using 关键字</em>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>名字空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</dd>
<dt>优点:</dt>
<dd><p class="first">虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 名字空间在这基础上又封装了一层.</p>
<p class="last">举例来说, 两个不同项目的全局作用域都有一个类 <tt class="docutils literal"><span class="pre">Foo</span></tt>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同名字空间中, <tt class="docutils literal"><span class="pre">project1::Foo</span></tt> 和 <tt class="docutils literal"><span class="pre">project2::Foo</span></tt> 作为不同符号自然不会冲突.</p>
</dd>
<dt>缺点:</dt>
<dd><p class="first">名字空间具有迷惑性, 因为它们和类一样提供了额外的 (可嵌套的) 命名轴线.</p>
<p class="last">在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p>
</dd>
<dt>结论:</dt>
<dd>根据下文将要提到的策略合理使用命名空间.</dd>
</dl>
<div class="section" id="id3">
<h5>2.1.1. 匿名名字空间</h5>
<ul>
<li><dl class="first docutils">
<dt>在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中, 允许甚至鼓励使用匿名名字空间, 以避免运行时的命名冲突:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="p">{</span>                             <span class="c1">// .cc 文件中</span>

<span class="c1">// 名字空间的内容无需缩进</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">kUNUSED</span><span class="p">,</span> <span class="n">kEOF</span><span class="p">,</span> <span class="n">kERROR</span> <span class="p">};</span>         <span class="c1">// 经常使用的符号</span>
<span class="kt">bool</span> <span class="nf">AtEof</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pos_</span> <span class="o">==</span> <span class="n">kEOF</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// 使用本名字空间内的符号 EOF</span>

<span class="p">}</span> <span class="c1">// namespace</span>
</pre></div>
</div>
</dd>
</dl>
<p>然而, 与特定类关联的文件作用域声明在该类中被声明为类型, 静态数据成员或静态成员函数, 而不是匿名名字空间的成员. 如上例所示, 匿名空间结束时用注释 <tt class="docutils literal"><span class="pre">//</span> <span class="pre">namespace</span></tt> 标识.</p>
</li>
<li><p class="first">不要在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中使用匿名名字空间.</p>
</li>
</ul>
</div>
<div class="section" id="id4">
<h5>2.1.2. 具名的名字空间</h5>
<p>具名的名字空间使用方式如下:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>用名字空间把文件包含, <a class="reference external" href="http://code.google.com/p/google-gflags/">gflags</a> 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它名字空间:</dt>
<dd><div class="first highlight-c++"><pre>// .h 文件
namespace mynamespace {

// 所有声明都置于命名空间中
// 注意不要使用缩进
class MyClass {
    public:
    …
    void Foo();
};

} // namespace mynamespace</pre>
</div>
<div class="highlight-c++"><pre>// .cc 文件
namespace mynamespace {

// 函数定义都置于命名空间中
void MyClass::Foo() {
    …
}

} // namespace mynamespace</pre>
</div>
<p>通常的 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件包含更多, 更复杂的细节, 比如引用其他名字空间的类等.</p>
<div class="last highlight-c++"><pre>#include “a.h”

DEFINE_bool(someflag, false, “dummy flag”);

class C;                    // 全局名字空间中类 C 的前置声明
namespace a { class A; }    // a::A 的前置声明

namespace b {

…code for b…                // b 中的代码

} // namespace b</pre>
</div>
</dd>
</dl>
</li>
<li><p class="first">不要在名字空间 <tt class="docutils literal"><span class="pre">std</span></tt> 内声明任何东西, 包括标准库的类前置声明. 在 <tt class="docutils literal"><span class="pre">std</span></tt> 名字空间声明实体会导致不确定的问题, 比如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</p>
</li>
<li><p class="first">最好不要使用 <em>``using`` 关键字</em>, 以保证名字空间下的所有名称都可以正常使用.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 禁止 —— 污染名字空间</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件, <tt class="docutils literal"><span class="pre">.h</span></tt> 文件的函数, 方法或类中, 可以使用 <em>``using`` 关键字</em>.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 允许: .cc 文件中</span>
<span class="c1">// .h 文件的话, 必须在函数, 方法或类的内部使用</span>
<span class="k">using</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件, <tt class="docutils literal"><span class="pre">.h</span></tt> 文件的函数, 方法或类中, 允许使用名字空间别名.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 允许: .cc 文件中</span>
<span class="c1">// .h 文件的话, 必须在函数, 方法或类的内部使用</span>

<span class="k">namespace</span> <span class="n">fbz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="id5">
<h4>2.2. 嵌套类</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当公有嵌套类作为接口的一部分时, 虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于名字空间内是更好的选择.</p>
</div>
<dl class="docutils">
<dt>定义: 在一个类内部定义另一个类; 嵌套类也被称为 <em>成员类 (member class)</em>.</dt>
<dd><div class="first last highlight-c++"><pre>class Foo {

private:
    // Bar是嵌套在Foo中的成员类
    class Bar {
        …
    };

};</pre>
</div>
</dd>
<dt>优点:</dt>
<dd>当嵌套 (或成员) 类只被外围类使用时非常有用; 把它作为外围类作用域内的成员, 而不是去污染外部作用域的同名类. 嵌套类可以在外围类中做前置声明, 然后在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中定义, 这样避免在外围类的声明中定义嵌套类, 因为嵌套类的定义通常只与实现相关.</dd>
<dt>缺点:</dt>
<dd>嵌套类只能在外围类的内部做前置声明. 因此, 任何使用了 <tt class="docutils literal"><span class="pre">Foo::Bar*</span></tt> 指针的头文件不得不包含类 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的整个声明.</dd>
<dt>结论:</dt>
<dd>不要将嵌套类定义成公有, 除非它们是接口的一部分, 比如, 嵌套类含有某些方法的一组选项.</dd>
</dl>
</div>
<div class="section" id="id6">
<h4>2.3. 非成员函数、静态成员函数和全局函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数.</p>
</div>
<dl class="docutils">
<dt>优点:</dt>
<dd>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在名字空间内可避免污染全局作用域.</dd>
<dt>缺点:</dt>
<dd>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</dd>
<dt>结论:</dt>
<dd><p class="first">有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个名字空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间.</p>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的名字空间内.</p>
<p class="last">如果你必须定义非成员函数, 又只是在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中使用它, 可使用匿名名字空间或 <tt class="docutils literal"><span class="pre">static</span></tt> 链接关键字 (如 <tt class="docutils literal"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">Foo()</span> <span class="pre">{...}</span></tt>) 限定其作用域.</p>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h4>2.4. 局部变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p>
</div>
<dl class="docutils">
<dt>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// 坏——初始化和声明分离</span>
<span class="n">nt</span> <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="p">();</span> <span class="c1">// 好——初始化时声明</span>
</pre></div>
</div>
</dd>
<dt>注意, GCC 可正确实现了 <tt class="docutils literal"><span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10;</span> <span class="pre">++i)</span></tt> (<tt class="docutils literal"><span class="pre">i</span></tt> 的作用域仅限 <tt class="docutils literal"><span class="pre">for</span></tt> 循环内), 所以其他 <tt class="docutils literal"><span class="pre">for</span></tt> 循环中可以重新使用 <tt class="docutils literal"><span class="pre">i</span></tt>. 在 <tt class="docutils literal"><span class="pre">if</span></tt> 和 <tt class="docutils literal"><span class="pre">while</span></tt> 等语句中的作用域声明也是正确的, 如:</dt>
<dd><div class="first highlight-c++"><pre>while (const char* p = strchr(str, ‘/’)) str = p + 1;</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数.</p>
</div>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// 低效的实现</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                  <span class="c1">// 构造函数和析构函数分别调用 1000000 次!</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>在循环作用域外面声明这类变量要高效的多:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                      <span class="c1">// 构造函数和析构函数只调用 1 次</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h4>2.5. 静态和全局变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">禁止使用 <tt class="docutils literal"><span class="pre">class</span></tt> 类型的静态或全局变量: 它们会导致很难发现的 bug 和不确定的构造和析构函数调用顺序.</p>
</div>
<p>静态生存周期的对象, 包括全局变量, 静态变量, 静态类成员变量, 以及函数静态变量, 都必须是原生数据类型 (POD : Plain Old Data): 只能是 <cite>int</cite>, <cite>char</cite>, <cite>float</cite>, 和 <cite>void</cite>, 以及 POD 类型的数组/结构体/指针. 永远不要使用函数返回值初始化静态变量; 不要在多线程代码中使用非 <tt class="docutils literal"><span class="pre">const</span></tt> 的静态变量.</p>
<p>不幸的是, 静态变量的构造函数, 析构函数以及初始化操作的调用顺序在 C++ 标准中未明确定义, 甚至每次编译构建都有可能会发生变化, 从而导致难以发现的 bug. 比如, 结束程序时, 某个静态变量已经被析构了, 但代码还在跑 &#8211; 其它线程很可能 &#8211; 试图访问该变量, 直接导致崩溃.</p>
<p>所以, 我们只允许 POD 类型的静态变量. 本条规则完全禁止 <tt class="docutils literal"><span class="pre">vector</span></tt> (使用 C 数组替代), <tt class="docutils literal"><span class="pre">string</span></tt> (使用 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt>), 及其它以任意方式包含或指向类实例的东东, 成为静态变量. 出于同样的理由, 我们不允许用函数返回值来初始化静态变量.</p>
<p>如果你确实需要一个 <tt class="docutils literal"><span class="pre">class`</span> <span class="pre">类型的静态或全局变量,</span> <span class="pre">可以考虑在</span> <span class="pre">``main()</span></tt> 函数或 <tt class="docutils literal"><span class="pre">pthread_once()</span></tt> 内初始化一个你永远不会回收的指针.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>yospaly 译注:</p>
<p class="last">上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p>
</div>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">cc</span></tt> 中的匿名名字空间可避免命名冲突, 限定作用域, 避免直接使用 <tt class="docutils literal"><span class="pre">using</span></tt> 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <tt class="docutils literal"><span class="pre">public</span></tt>;</li>
<li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li>
<li>多线程中的全局变量 (含静态成员变量) 不要使用 <tt class="docutils literal"><span class="pre">class</span></tt> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/classes"></span><div class="section" id="id1">
<h3>3. 类</h3>
<p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.</p>
<div class="section" id="id2">
<h4>3.1. 构造函数的职责</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">构造函数中只进行那些没什么意义的 (trivial, YuleFox 注: 简单初始化对于程序执行没有实际的逻辑意义, 因为成员变量 &#8220;有意义&#8221; 的值大多不在构造函数中确定) 初始化, 可能的话, 使用 <tt class="docutils literal"><span class="pre">Init()</span></tt> 方法集中初始化有意义的 (non-trivial) 数据.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>在构造函数体中进行初始化操作.</dd>
<dt>优点:</dt>
<dd>排版方便, 无需担心类是否已经初始化.</dd>
<dt>缺点:</dt>
<dd><p class="first">在构造函数中执行操作引起的问题有:</p>
<blockquote class="last">
<div><ul class="simple">
<li>构造函数中很难上报错误, <a class="reference external" href="#...">不能使用异常</a>.</li>
<li>操作失败会造成对象初始化失败，进入不确定状态.</li>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>如果有人创建该类型的全局变量 (虽然违背了上节提到的规则), 构造函数将先 <tt class="docutils literal"><span class="pre">main()</span></tt> 一步被调用, 有可能破坏构造函数中暗含的假设条件. 例如, <a class="reference external" href="http://code.google.com/p/google-gflags/">gflags</a> 尚未初始化.</li>
</ul>
</div></blockquote>
</dd>
<dt>结论:</dt>
<dd>如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 <tt class="docutils literal"><span class="pre">Init()</span></tt> 方法并 (或) 增加一个成员标记用于指示对象是否已经初始化成功.</dd>
</dl>
</div>
<div class="section" id="id4">
<h4>3.2. 默认构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果一个类定义了若干成员变量又没有其它构造函数, 必须定义一个默认构造函数. 否则编译器将自动生产一个很糟糕的默认构造函数.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><tt class="docutils literal"><span class="pre">new</span></tt> 一个不带参数的类对象时, 会调用这个类的默认构造函数. 用 <tt class="docutils literal"><span class="pre">new[]</span></tt> 创建数组时，默认构造函数则总是被调用.</dd>
<dt>优点:</dt>
<dd>默认将结构体初始化为 &#8220;无效&#8221; 值, 使调试更方便.</dd>
<dt>缺点:</dt>
<dd>对代码编写者来说, 这是多余的工作.</dd>
<dt>结论:</dt>
<dd><p class="first">如果类中定义了成员变量, 而且没有提供其它构造函数, 你必须定义一个 (不带参数的) 默认构造函数. 把对象的内部状态初始化成一致/有效的值无疑是更合理的方式.</p>
<p>这么做的原因是: 如果你没有提供其它构造函数, 又没有定义默认构造函数, 编译器将为你自动生成一个. 编译器生成的构造函数并不会对对象进行合理的初始化.</p>
<p class="last">如果你定义的类继承现有类, 而你又没有增加新的成员变量, 则不需要为新类定义默认构造函数.</p>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h4>3.3. 显式构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对单个参数的构造函数使用 C++ 关键字 <tt class="docutils literal"><span class="pre">explicit</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>通常, 如果构造函数只有一个参数, 可看成是一种隐式转换. 打个比方, 如果你定义了 <tt class="docutils literal"><span class="pre">Foo::Foo(string</span> <span class="pre">name)</span></tt>, 接着把一个字符串传给一个以 <tt class="docutils literal"><span class="pre">Foo</span></tt> 对象为参数的函数, 构造函数 <tt class="docutils literal"><span class="pre">Foo::Foo(string</span> <span class="pre">name)</span></tt> 将被调用, 并将该字符串转换为一个 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的临时对象传给调用函数. 看上去很方便, 但如果你并不希望如此通过转换生成一个新对象的话, 麻烦也随之而来. 为避免构造函数被调用造成隐式转换, 可以将其声明为 <tt class="docutils literal"><span class="pre">explicit</span></tt>.</dd>
<dt>优点:</dt>
<dd>避免不合时宜的变换.</dd>
<dt>缺点:</dt>
<dd>无</dd>
<dt>结论:</dt>
<dd><p class="first">所有单参数构造函数都必须是显式的. 在类定义中, 将关键字 <tt class="docutils literal"><span class="pre">explicit</span></tt> 加到单参数构造函数前: <tt class="docutils literal"><span class="pre">explicit</span> <span class="pre">Foo(string</span> <span class="pre">name);</span></tt></p>
<p class="last">例外: 在极少数情况下, 拷贝构造函数可以不声明成 <tt class="docutils literal"><span class="pre">explicit</span></tt>. 作为其它类的透明包装器的类也是特例之一. 类似的例外情况应在注释中明确说明.</p>
</dd>
</dl>
</div>
<div class="section" id="copy-constructors">
<span id="id6"></span><h4>3.4. 拷贝构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数; 大部分情况下都不需要, 此时应使用 <tt class="docutils literal"><span class="pre">DISALLOW_COPY_AND_ASSIGN</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>拷贝构造函数在复制一个对象到新建对象时被调用 (特别是对象传值时).</dd>
<dt>优点:</dt>
<dd>拷贝构造函数使得拷贝对象更加容易. STL 容器要求所有内容可拷贝, 可赋值.</dd>
<dt>缺点:</dt>
<dd>C++ 中的隐式对象拷贝是很多性能问题和 bug 的根源. 拷贝构造函数降低了代码可读性, 相比传引用, 跟踪传值的对象更加困难, 对象修改的地方变得难以捉摸.</dd>
<dt>结论:</dt>
<dd><p class="first">大部分类并不需要可拷贝, 也不需要一个拷贝构造函数或重载赋值运算符. 不幸的是, 如果你不主动声明它们, 编译器会为你自动生成, 而且是 <tt class="docutils literal"><span class="pre">public</span></tt> 的.</p>
<dl class="docutils">
<dt>可以考虑在类的 <tt class="docutils literal"><span class="pre">private:</span></tt> 中添加拷贝构造函数和赋值操作的空实现, 只有声明, 没有定义. 由于这些空函数声明为 <tt class="docutils literal"><span class="pre">private</span></tt>, 当其他代码试图使用它们的时候, 编译器将报错. 方便起见, 我们可以使用 <tt class="docutils literal"><span class="pre">DISALLOW_COPY_AND_ASSIGN</span></tt> 宏:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="c1">// 禁止使用拷贝构造函数和 operator= 赋值操作的宏</span>
<span class="c1">// 应该类的 private: 中使用</span>

<span class="cp">#define DISALLOW_COPY_AND_ASSIGN(TypeName) \</span>
<span class="cp">            TypeName(const TypeName&amp;); \</span>
<span class="cp">            void operator=(const TypeName&amp;)</span>
</pre></div>
</div>
</dd>
<dt>在 <tt class="docutils literal"><span class="pre">class</span> <span class="pre">foo:</span></tt> 中:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">f</span><span class="p">);</span>
        <span class="o">~</span><span class="n">Foo</span><span class="p">();</span>

    <span class="nl">private:</span>
        <span class="n">DISALLOW_COPY_AND_ASSIGN</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd>
</dl>
<p class="last">如上所述, 绝大多数情况下都应使用 <tt class="docutils literal"><span class="pre">DISALLOW_COPY_AND_ASSIGN</span></tt> 宏. 如果类确实需要可拷贝, 应在该类的头文件中说明原由, 并合理的定义拷贝构造函数和赋值操作. 注意在 <tt class="docutils literal"><span class="pre">operator=</span></tt> 中检测自我赋值的情况 (yospaly 注: 即 <tt class="docutils literal"><span class="pre">operator=</span></tt> 接收的参数是该对象本身).</p>
</dd>
</dl>
<p>为了能作为 STL 容器的值, 你可能有使类可拷贝的冲动. 在大多数类似的情况下, 真正该做的是把对象的 <em>指针</em> 放到 STL 容器中. 可以考虑使用 <tt class="docutils literal"><span class="pre">std::tr1::shared_ptr</span></tt>.</p>
</div>
<div class="section" id="vs">
<span id="structs-vs-classes"></span><h4>3.5. 结构体 VS. 类</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">仅当只有数据时使用 <tt class="docutils literal"><span class="pre">struct</span></tt>, 其它一概使用 <tt class="docutils literal"><span class="pre">class</span></tt>.</p>
</div>
<p>在 C++ 中 <tt class="docutils literal"><span class="pre">struct</span></tt> 和 <tt class="docutils literal"><span class="pre">class</span></tt> 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.</p>
<p><tt class="docutils literal"><span class="pre">struct</span></tt> 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域 (field), 而非函数调用. 除了构造函数, 析构函数, <tt class="docutils literal"><span class="pre">Initialize()</span></tt>, <tt class="docutils literal"><span class="pre">Reset()</span></tt>, <tt class="docutils literal"><span class="pre">Validate()</span></tt> 外, 不能提供其它功能的函数.</p>
<p>如果需要更多的函数功能, <tt class="docutils literal"><span class="pre">class</span></tt> 更适合. 如果拿不准, 就用 <tt class="docutils literal"><span class="pre">class</span></tt>.</p>
<p>为了和 STL 保持一致, 对于仿函数 (functors) 和特性 (traits) 可以不用 <tt class="docutils literal"><span class="pre">class</span></tt> 而是使用 <tt class="docutils literal"><span class="pre">struct</span></tt>.</p>
<p>注意: 类和结构体的成员变量使用 <a class="reference external" href="...">不同的命名规则</a>.</p>
</div>
<div class="section" id="inheritance">
<span id="id8"></span><h4>3.6. 继承</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用组合 (composition, YuleFox 注: 这一点也是 GoF 在 &lt;&lt;Design Patterns&gt;&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 <tt class="docutils literal"><span class="pre">public</span></tt> 继承.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承 (implementation inheritance), 子类继承父类的实现代码; 接口继承 (interface inheritance), 子类仅继承父类的方法名称.</dd>
<dt>优点:</dt>
<dd>实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</dd>
<dt>缺点:</dt>
<dd>对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 还要区分基类的实际布局.</dd>
<dt>结论:</dt>
<dd><p class="first">所有继承必须是 <tt class="docutils literal"><span class="pre">public</span></tt> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 &#8220;是一个&#8221; (&#8220;is-a&#8221;, YuleFox 注: 其他 &#8220;has-a&#8221; 情况下请使用组合) 的情况下使用继承: 如果 <tt class="docutils literal"><span class="pre">Bar</span></tt> 的确 &#8220;是一种&#8221; Foo, <tt class="docutils literal"><span class="pre">Bar</span></tt> 才能继承 <tt class="docutils literal"><span class="pre">Foo</span></tt>.</p>
<p>必要的话, 析构函数声明为 <tt class="docutils literal"><span class="pre">virtual</span></tt>. 如果你的类有虚函数, 则析构函数也应该为虚函数. 注意 <a class="reference external" href="....">数据成员在任何情况下都必须是私有的</a>.</p>
<p class="last">当重载一个虚函数, 在衍生类中把它明确的声明为 <tt class="docutils literal"><span class="pre">virtual</span></tt>. 理论依据: 如果省略 <tt class="docutils literal"><span class="pre">virtual</span></tt> 关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
</dd>
</dl>
</div>
<div class="section" id="multiple-inheritance">
<span id="id10"></span><h4>3.7. 多重继承</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 为后缀的 <a class="reference internal" href="contents.html#interface"><em>纯接口类</em></a>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>多重继承允许子类拥有多个基类. 要将作为 <em>纯接口</em> 的基类和具有 <em>实现</em> 的基类区别开来.</dd>
<dt>优点:</dt>
<dd>相比单继承 (见 <a class="reference internal" href="contents.html#inheritance"><em>继承</em></a>), 多重实现继承可以复用更多的代码.</dd>
<dt>缺点:</dt>
<dd>真正需要用到多重 <em>实现</em> 继承的情况少之又少. 多重实现继承看上去是不错的解决方案, 但你通常也可以找到一个更明确, 更清晰的不同解决方案.</dd>
<dt>结论:</dt>
<dd>只有当所有父类除第一个外都是 <a class="reference internal" href="contents.html#interface"><em>纯接口类</em></a> 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 为后缀.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">关于该规则, Windows 下有个 <a class="reference internal" href="contents.html#windows-code"><em>特例</em></a>.</p>
</div>
</div>
<div class="section" id="interface">
<span id="id11"></span><h4>3.8. 接口</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">接口是指满足特定条件的类, 这些类以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 为后缀 (不强制).</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first">当一个类满足以下要求时, 称之为纯接口:</p>
<blockquote>
<div><ul class="simple">
<li>只有纯虚函数 (&#8220;<tt class="docutils literal"><span class="pre">=0</span></tt>&#8221;) 和静态函数 (除了下文提到的析构函数).</li>
<li>没有非静态数据成员.</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 <tt class="docutils literal"><span class="pre">protected</span></tt>.</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 为后缀的类继承.</li>
</ul>
</div></blockquote>
<p class="last">接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 <em>The C++ Programming Language, 3rd edition</em> 第 12.4 节.</p>
</dd>
<dt>优点:</dt>
<dd>以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 <a class="reference internal" href="contents.html#multiple-inheritance"><em>多重继承</em></a> 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</dd>
<dt>缺点:</dt>
<dd><tt class="docutils literal"><span class="pre">Interface</span></tt> 后缀增加了类名长度, 为阅读和理解带来不便. 同时，接口特性作为实现细节不应暴露给用户.</dd>
<dt>结论:</dt>
<dd>只有在满足上述需要时, 类才以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 结尾, 但反过来, 满足上述需要的类未必一定以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 结尾.</dd>
</dl>
</div>
<div class="section" id="id12">
<h4>3.9. 运算符重载</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">除少数特定环境外，不要重载运算符.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>一个类可以定义诸如 <tt class="docutils literal"><span class="pre">+</span></tt> 和 <tt class="docutils literal"><span class="pre">/</span></tt> 等运算符, 使其可以像内建类型一样直接操作.</dd>
<dt>优点:</dt>
<dd>使代码看上去更加直观, 类表现的和内建类型 (如 <tt class="docutils literal"><span class="pre">int</span></tt>) 行为一致. 重载运算符使 <tt class="docutils literal"><span class="pre">Equals()</span></tt>, <tt class="docutils literal"><span class="pre">Add()</span></tt> 等函数名黯然失色. 为了使一些模板函数正确工作, 你可能必须定义操作符.</dd>
<dt>缺点:</dt>
<dd><p class="first">虽然操作符重载令代码更加直观, 但也有一些不足:</p>
<ul class="simple">
<li>混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>更难定位重载运算符的调用点, 查找 <tt class="docutils literal"><span class="pre">Equals()</span></tt> 显然比对应的 <tt class="docutils literal"><span class="pre">==</span></tt> 调用点要容易的多.</li>
<li>有的运算符可以对指针进行操作, 容易导致 bug. <tt class="docutils literal"><span class="pre">Foo</span> <span class="pre">+</span> <span class="pre">4</span></tt> 做的是一件事, 而 <tt class="docutils literal"><span class="pre">&amp;Foo</span> <span class="pre">+</span> <span class="pre">4</span></tt> 可能做的是完全不同的另一件事. 对于二者, 编译器都不会报错, 使其很难调试;</li>
</ul>
<p class="last">重载还有令你吃惊的副作用. 比如, 重载了 <tt class="docutils literal"><span class="pre">operator&amp;</span></tt> 的类不能被前置声明.</p>
</dd>
<dt>结论:</dt>
<dd><p class="first">一般不要重载运算符. 尤其是赋值操作 (<tt class="docutils literal"><span class="pre">operator=</span></tt>) 比较诡异, 应避免重载. 如果需要的话, 可以定义类似 <tt class="docutils literal"><span class="pre">Equals()</span></tt>, <tt class="docutils literal"><span class="pre">CopyFrom()</span></tt> 等函数.</p>
<p>然而, 极少数情况下可能需要重载运算符以便与模板或 &#8220;标准&#8221; C++ 类互操作 (如 <tt class="docutils literal"><span class="pre">operator&lt;&lt;(ostream&amp;,</span> <span class="pre">const</span> <span class="pre">T&amp;)</span></tt>). 只有被证明是完全合理的才能重载, 但你还是要尽可能避免这样做. 尤其是不要仅仅为了在 STL 容器中用作键值就重载 <tt class="docutils literal"><span class="pre">operator==</span></tt> 或 <tt class="docutils literal"><span class="pre">operator&lt;</span></tt>; 相反, 你应该在声明容器的时候, 创建相等判断和大小比较的仿函数类型.</p>
<p>有些 STL 算法确实需要重载 <tt class="docutils literal"><span class="pre">operator==</span></tt> 时, 你可以这么做, 记得别忘了在文档中说明原因.</p>
<p class="last">参考 <a class="reference internal" href="contents.html#copy-constructors"><em>拷贝构造函数</em></a> 和 <a class="reference internal" href="contents.html#function-overloading"><em>函数重载</em></a>.</p>
</dd>
</dl>
</div>
<div class="section" id="id13">
<h4>3.10. 存取控制</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将 <em>所有</em> 数据成员声明为 <tt class="docutils literal"><span class="pre">private</span></tt>, 并根据需要提供相应的存取函数. 例如, 某个名为 <tt class="docutils literal"><span class="pre">foo_</span></tt> 的变量, 其取值函数是 <tt class="docutils literal"><span class="pre">foo()</span></tt>. 还可能需要一个赋值函数 <tt class="docutils literal"><span class="pre">set_foo()</span></tt>.</p>
</div>
<p>一般在头文件中把存取函数定义成内联函数.</p>
<p>参考 <a class="reference internal" href="contents.html#inheritance"><em>继承</em></a> 和 <a class="reference internal" href="contents.html#function-names"><em>函数命名</em></a></p>
</div>
<div class="section" id="declaration-order">
<span id="id14"></span><h4>3.11. 声明顺序</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在类中使用特定的声明顺序: <tt class="docutils literal"><span class="pre">public:</span></tt> 在 <tt class="docutils literal"><span class="pre">private:</span></tt> 之前, 成员函数在数据成员 (变量) 前;</p>
</div>
<p>类的访问控制区段的声明顺序依次为: <tt class="docutils literal"><span class="pre">public:</span></tt>, <tt class="docutils literal"><span class="pre">protected:</span></tt>, <tt class="docutils literal"><span class="pre">private:</span></tt>. 如果某区段没内容, 可以不声明.</p>
<p>每个区段内的声明通常按以下顺序:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">typedefs</span></tt> 和枚举</li>
<li>常量</li>
<li>构造函数</li>
<li>析构函数</li>
<li>成员函数, 含静态成员函数</li>
<li>数据成员, 含静态数据成员</li>
</ul>
</div></blockquote>
<p>宏 <tt class="docutils literal"><span class="pre">DISALLOW_COPY_AND_ASSIGN</span></tt> 的调用放在 <tt class="docutils literal"><span class="pre">private:</span></tt> 区段的末尾. 它通常是类的最后部分. 参考 <a class="reference internal" href="contents.html#copy-constructors"><em>拷贝构造函数</em></a>.</p>
<p><tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中函数的定义应尽可能和声明顺序一致.</p>
<p>不要在类定义中内联大型函数. 通常, 只有那些没有特别意义或性能要求高, 并且是比较短小的函数才能被定义为内联函数. 更多细节参考 <a class="reference internal" href="contents.html#inline-functions"><em>内联函数</em></a>.</p>
</div>
<div class="section" id="id15">
<h4>3.12. 编写简短函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">倾向编写简短, 凝练的函数.</p>
</div>
<p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题. 甚至导致难以发现的 bug. 使函数尽量简短, 便于他人阅读和修改代码.</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试困难, 或者你需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>不在构造函数中做太多逻辑相关的初始化;</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li>
<li>为避免隐式转换, 需将单参数构造函数声明为 <tt class="docutils literal"><span class="pre">explicit</span></tt>;</li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 <tt class="docutils literal"><span class="pre">private</span></tt> 且无需实现;</li>
<li>仅在作为数据集合时使用 <tt class="docutils literal"><span class="pre">struct</span></tt>;</li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 <tt class="docutils literal"><span class="pre">virtual</span></tt> 关键字, 虽然编译器允许不这样做;</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li>
<li>接口类类名以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话，声明为 <tt class="docutils literal"><span class="pre">protected</span></tt>;</li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li>
<li>存取函数一般内联在头文件中;</li>
<li>声明次序: <tt class="docutils literal"><span class="pre">public</span></tt> -&gt; <tt class="docutils literal"><span class="pre">protected</span></tt> -&gt; <tt class="docutils literal"><span class="pre">private</span></tt>;</li>
<li>函数体尽量短小, 紧凑, 功能单一;</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/magic"></span><div class="section" id="google">
<h3>4. 来自 Google 的奇技</h3>
<p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p>
<div class="section" id="id1">
<h4>4.1. 智能指针</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果确实需要使用智能指针的话, <tt class="docutils literal"><span class="pre">scoped_ptr</span></tt> 完全可以胜任. 你应该只在非常特定的情况下使用 <tt class="docutils literal"><span class="pre">std::tr1::shared_ptr</span></tt>, 例如 STL 容器中的对象. 任何情况下都不要使用 <tt class="docutils literal"><span class="pre">auto_ptr</span></tt>.</p>
</div>
<p>&#8220;智能&#8221; 指针看上去是指针, 其实是附加了语义的对象. 以 <tt class="docutils literal"><span class="pre">scoped_ptr</span></tt> 为例, <tt class="docutils literal"><span class="pre">scoped_ptr</span></tt> 被销毁时, 它会删除所指向的对象. <tt class="docutils literal"><span class="pre">shared_ptr</span></tt> 也是如此, 并且 <tt class="docutils literal"><span class="pre">shared_ptr</span></tt> 实现了引用计数, 所以最后一个 <tt class="docutils literal"><span class="pre">shared_ptr</span></tt> 对象析构时, 如果检测到引用次数为 0，就会销毁所指向的对象.</p>
<p>一般来说，我们倾向于设计对象隶属明确的代码, 最明确的对象隶属是根本不使用指针, 直接将对象作为一个作用域或局部变量使用. 另一种极端做法是, 引用计数指针不属于任何对象. 这种方法的问题是容易导致循环引用, 或者导致某个对象无法删除的诡异状态, 而且在每一次拷贝或赋值时连原子操作都会很慢.</p>
<p>虽然不推荐使用引用计数指针, 但有些时候它们的确是最简单有效的解决方案.</p>
<p>(YuleFox 注: 看来, Google 所谓的不同之处, 在于尽量避免使用智能指针 :D, 使用时也尽量局部化, 并且, 安全第一)</p>
</div>
<div class="section" id="cpplint">
<h4>4.2. cpplint</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <tt class="docutils literal"><span class="pre">cpplint.py</span></tt> 检查风格错误.</p>
</div>
<p><tt class="docutils literal"><span class="pre">cpplint.py</span></tt> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 用行注释 <tt class="docutils literal"><span class="pre">//</span> <span class="pre">NOLINT</span></tt> 可以忽略误报.</p>
<p>某些项目会指导你如何使用他们的项目工具运行 <tt class="docutils literal"><span class="pre">cpplint.py</span></tt>. 如果你参与的项目没有提供, 你可以单独下载 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py">cpplint.py</a>.</p>
</div>
</div>
<span id="document-google-cpp-styleguide/others"></span><div class="section" id="c">
<h3>5. 其他 C++ 特性</h3>
<div class="section" id="id1">
<h4>5.1. 引用参数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所以按引用传递的参数必须加上 <tt class="docutils literal"><span class="pre">const</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">*pval)</span></tt>. 在 C++ 中, 函数还可以声明引用参数: <tt class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">&amp;val)</span></tt>.</dd>
<dt>优点:</dt>
<dd>定义引用参数防止出现 <tt class="docutils literal"><span class="pre">(*pval)++</span></tt> 这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <tt class="docutils literal"><span class="pre">NULL</span></tt> 指针.</dd>
<dt>缺点:</dt>
<dd>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</dd>
<dt>结论:</dt>
<dd><dl class="first docutils">
<dt>函数参数列表中, 所有引用参数都必须是 <tt class="docutils literal"><span class="pre">const</span></tt>:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
</dd>
</dl>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <tt class="docutils literal"><span class="pre">const</span></tt> 引用, 输出参数为指针. 输入参数可以是 <tt class="docutils literal"><span class="pre">const</span></tt> 指针, 但决不能是 非 <tt class="docutils literal"><span class="pre">const</span></tt> 的引用参数.</p>
<p class="last">在以下情况你可以把输入参数定义为 <tt class="docutils literal"><span class="pre">const</span></tt> 指针: 你想强调参数不是拷贝而来的, 在对象生存周期内必须一直存在; 最好同时在注释中详细说明一下. <tt class="docutils literal"><span class="pre">bind2nd</span></tt> 和 <tt class="docutils literal"><span class="pre">mem_fun</span></tt> 等 STL 适配器不接受引用参数, 这种情况下你也必须把函数参数声明成指针类型.</p>
</dd>
</dl>
</div>
<div class="section" id="function-overloading">
<span id="id2"></span><h4>5.2. 函数重载</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">仅在输入参数类型不同, 功能相同时使用重载函数 (含构造函数). 不要用函数重载模拟 <a class="reference external" href="http://code.google.com/p/google-gflags/">缺省函数参数</a>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><dl class="first last docutils">
<dt>你可以编写一个参数类型为 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">string&amp;</span></tt> 的函数, 然后用另一个参数类型为 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt> 的函数重载它:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">textlen</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt>优点:</dt>
<dd>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</dd>
<dt>缺点:</dt>
<dd>限制使用重载的一个原因是在某个特定调用点很难确定到底调用的是哪个函数. 另一个原因是当派生类只重载了某个函数的部分变体, 会令很多人对继承的语义产生困惑. 此外在阅读库的用户代码时, 可能会因反对使用 <a class="reference external" href="http://code.google.com/p/google-gflags/">缺省函数参数</a> 造成不必要的费解.</dd>
<dt>结论:</dt>
<dd>如果你想重载一个函数, 考虑让函数名包含参数信息, 例如, 使用 <tt class="docutils literal"><span class="pre">AppendString()</span></tt>, <tt class="docutils literal"><span class="pre">AppendInt()</span></tt> 而不是 <tt class="docutils literal"><span class="pre">Append()</span></tt>.</dd>
</dl>
</div>
<div class="section" id="id5">
<h4>5.3. 缺省参数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不允许使用缺省函数参数.</p>
</div>
<dl class="docutils">
<dt>优点:</dt>
<dd>多数情况下, 你写的函数可能会用到很多的缺省值, 但偶尔你也会修改这些缺省值. 无须为了这些偶尔情况定义很多的函数, 用缺省参数就能很轻松的做到这点.</dd>
<dt>缺点:</dt>
<dd>大家通常都是通过查看别人的代码来推断如何使用 API. 用了缺省参数的代码更难维护, 从老代码复制粘贴而来的新代码可能只包含部分参数. 当缺省参数不适用于新代码时可能会导致重大问题.</dd>
<dt>结论:</dt>
<dd>我们规定所有参数必须明确指定, 迫使程序员理解 API 和各参数值的意义, 避免默默使用他们可能都还没意识到的缺省参数.</dd>
</dl>
</div>
<div class="section" id="alloca">
<h4>5.4. 变长数组和 alloca()</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不允许使用变长数组和 <tt class="docutils literal"><span class="pre">alloca()</span></tt>.</p>
</div>
<dl class="docutils">
<dt>优点:</dt>
<dd>变长数组具有浑然天成的语法. 变长数组和 <tt class="docutils literal"><span class="pre">alloca()</span></tt> 也都很高效.</dd>
<dt>缺点:</dt>
<dd>变长数组和 <tt class="docutils literal"><span class="pre">alloca()</span></tt> 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: &#8220;在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了&#8221;.</dd>
<dt>结论:</dt>
<dd>使用安全的内存分配器, 如 <tt class="docutils literal"><span class="pre">scoped_ptr</span></tt> / <tt class="docutils literal"><span class="pre">scoped_array</span></tt>.</dd>
</dl>
</div>
<div class="section" id="id6">
<h4>5.5. 友元</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们允许合理的使用友元类及友元函数.</p>
</div>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 <tt class="docutils literal"><span class="pre">FooBuilder</span></tt> 声明为 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的友元, 以便 <tt class="docutils literal"><span class="pre">FooBuilder</span></tt> 正确构造 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 <tt class="docutils literal"><span class="pre">public</span></tt>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p>
</div>
<div class="section" id="id7">
<h4>5.6. 异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不使用 C++ 异常.</p>
</div>
<dl class="docutils">
<dt>优点:</dt>
<dd><ul class="first last simple">
<li>异常允许上层应用决定如何处理在底层嵌套函数中 &#8220;不可能出现的&#8221; 失败, 不像错误码记录那么含糊又易出错;</li>
<li>很多现代语言都使用异常. 引入异常使得 C++ 与 Python, Java 以及其它 C++ 相近的语言更加兼容.</li>
<li>许多第三方 C++ 库使用异常, 禁用异常将导致很难集成这些库.</li>
<li>异常是处理构造函数失败的唯一方法. 虽然可以通过工厂函数或 <tt class="docutils literal"><span class="pre">Init()</span></tt> 方法替代异常, 但他们分别需要堆分配或新的 &#8220;无效&#8221; 状态；</li>
<li>在测试框架中使用异常确实很方便.</li>
</ul>
</dd>
<dt>缺点:</dt>
<dd><ul class="first last simple">
<li>在现有函数中添加 <tt class="docutils literal"><span class="pre">throw</span></tt> 语句时, 你必须检查所有调用点. 所有调用点得至少有基本的异常安全保护, 否则永远捕获不到异常, 只好 &#8220;开心的&#8221; 接受程序终止的结果. 例如, 如果 <tt class="docutils literal"><span class="pre">f()</span></tt> 调用了 <tt class="docutils literal"><span class="pre">g()</span></tt>, <tt class="docutils literal"><span class="pre">g()</span></tt> 又调用了 <tt class="docutils literal"><span class="pre">h()</span></tt>, <tt class="docutils literal"><span class="pre">h</span></tt> 抛出的异常被 <tt class="docutils literal"><span class="pre">f</span></tt> 捕获, <tt class="docutils literal"><span class="pre">g</span></tt> 要当心了, 很可能会因疏忽而未被妥善清理.</li>
<li>更普遍的情况是, 如果使用异常, 光凭查看代码是很难评估程序的控制流: 函数返回点可能在你意料之外. 这回导致代码管理和调试困难. 你可以通过规定何时何地如何使用异常来降低开销, 但是让开发人员必须掌握并理解这些规定带来的代价更大.</li>
<li>异常安全要求同时采用 RAII 和不同编程实践. 要想轻松编写正确的异常安全代码, 需要大量的支撑机制配合. 另外, 要避免代码读者去理解整个调用结构图, 异常安全代码必须把写持久化状态的逻辑部分隔离到 &#8220;提交&#8221; 阶段. 它在带来好处的同时, 还有成本 (也许你不得不为了隔离 &#8220;提交&#8221; 而整出令人费解的代码). 允许使用异常会驱使我们不断为此付出代价, 即使我们觉得这很不划算.</li>
<li>启用异常使生成的二进制文件体积变大, 延长了编译时间 (或许影响不大), 还可能增加地址空间压力;</li>
<li>异常的实用性可能会怂恿开发人员在不恰当的时候抛出异常, 或者在不安全的地方从异常中恢复. 例如, 处理非法用户输入时就不应该抛出异常. 如果我们要完全列出这些约束, 这份风格指南会长出很多!</li>
</ul>
</dd>
<dt>结论:</dt>
<dd><p class="first">从表面上看, 使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p>
<p>鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.</p>
<p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p>
<p class="last">对于 Windows 代码来说, 有个 <a class="reference internal" href="contents.html#windows-code"><em>特例</em></a>.</p>
</dd>
</dl>
<p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)</p>
</div>
<div class="section" id="id8">
<h4>5.7. 运行时类型识别</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们禁止使用 RTTI.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>RTTI 允许程序员在运行时识别 C++ 类对象的类型.</dd>
<dt>优点:</dt>
<dd><p class="first">RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型.</p>
<p class="last">除测试外, 极少用到.</p>
</dd>
<dt>缺点:</dt>
<dd>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</dd>
<dt>结论:</dt>
<dd><p class="first">除单元测试外, 不要使用 RTTI. 如果你发现自己不得不写一些行为逻辑取决于对象类型的代码, 考虑换一种方式判断对象类型.</p>
<p>如果要实现根据子类类型来确定执行不同逻辑代码, 虚函数无疑更合适. 在对象内部就可以处理类型识别问题.</p>
<p>如果要在对象外部的代码中判断类型, 考虑使用双重分派方案, 如访问者模式. 可以方便的在对象本身之外确定类的类型.</p>
<p class="last">如果你认为上面的方法你真的掌握不了, 你可以使用 RTTI, 但务必请三思 :-) . 不要试图手工实现一个貌似 RTTI 的替代方案, 我们反对使用 RTTI 的理由, 同样适用于那些在类型继承体系上使用类型标签的替代方案.</p>
</dd>
</dl>
</div>
<div class="section" id="id9">
<h4>5.8. 类型转换</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 C++ 的类型转换, 如 <tt class="docutils literal"><span class="pre">static_cast&lt;&gt;()</span></tt>. 不要使用 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">(int)x</span></tt> 或 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">int(x)</span></tt> 等转换方式;</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</dd>
<dt>优点:</dt>
<dd>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 <tt class="docutils literal"><span class="pre">(int)3.5</span></tt>), 有时是在做类型转换 (如 <tt class="docutils literal"><span class="pre">(int)&quot;hello&quot;</span></tt>). 另外, C++ 的类型转换在查找时更醒目.</dd>
<dt>缺点:</dt>
<dd>恶心的语法.</dd>
<dt>结论:</dt>
<dd><p class="first">不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<blockquote class="last">
<div><ul class="simple">
<li>用 <tt class="docutils literal"><span class="pre">static_cast</span></tt> 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用 <tt class="docutils literal"><span class="pre">const_cast</span></tt> 去掉 <tt class="docutils literal"><span class="pre">const</span></tt> 限定符.</li>
<li>用 <tt class="docutils literal"><span class="pre">reinterpret_cast</span></tt> 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
<li><tt class="docutils literal"><span class="pre">dynamic_cast</span></tt> 测试代码以外不要使用. 除非是单元测试, 如果你需要在运行时确定类型信息, 说明有 <a class="reference external" href="designflaw">设计缺陷</a>.</li>
</ul>
</div></blockquote>
</dd>
</dl>
</div>
<div class="section" id="id11">
<h4>5.9. 流</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只在记录日志时使用流.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>流用来替代 <tt class="docutils literal"><span class="pre">printf()</span></tt> 和 <tt class="docutils literal"><span class="pre">scanf()</span></tt>.</dd>
<dt>优点:</dt>
<dd>有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 <tt class="docutils literal"><span class="pre">printf</span></tt> 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.</dd>
<dt>缺点:</dt>
<dd>流使得 <tt class="docutils literal"><span class="pre">pread()</span></tt> 等功能函数很难执行. 如果不使用 <tt class="docutils literal"><span class="pre">printf</span></tt> 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 <tt class="docutils literal"><span class="pre">%.*s</span></tt>) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</dd>
<dt>结论:</dt>
<dd><p class="first">不要使用流, 除非是日志接口需要. 使用 <tt class="docutils literal"><span class="pre">printf</span></tt> 之类的代替.</p>
<p class="last">使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
</dd>
<dt>拓展讨论:</dt>
<dd><p class="first">对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 <tt class="docutils literal"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></tt>. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p>
<dl class="docutils">
<dt>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势. 流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="p">;</span>   <span class="c1">// Prints the address</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">// Prints the contents</span>
</pre></div>
</div>
</dd>
</dl>
<p>由于 <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载.</p>
<dl class="docutils">
<dt>有人说 <tt class="docutils literal"><span class="pre">printf</span></tt> 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error connecting to &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span>
     <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error connecting to &#39;%s:%u: %s&quot;</span><span class="p">,</span>
        <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span><span class="p">,</span>
        <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</pre></div>
</div>
</dd>
</dl>
<p>你可能会说, &#8220;把流封装一下就会比较好了&#8221;, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备.</p>
<p class="last">每一种方式都是各有利弊, &#8220;没有最好, 只有更适合&#8221;. 简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 <tt class="docutils literal"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></tt>.</p>
</dd>
</dl>
</div>
<div class="section" id="id12">
<h4>5.10. 前置自增和自减</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对于迭代器和其他模板对象使用前缀形式 (<tt class="docutils literal"><span class="pre">++i</span></tt>) 的自增, 自减运算符.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>对于变量在自增 (<tt class="docutils literal"><span class="pre">++i</span></tt> 或 <tt class="docutils literal"><span class="pre">i++</span></tt>) 或自减 (<tt class="docutils literal"><span class="pre">--i</span></tt> 或 <tt class="docutils literal"><span class="pre">i--</span></tt>) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</dd>
<dt>优点:</dt>
<dd>不考虑返回值的话, 前置自增 (<tt class="docutils literal"><span class="pre">++i</span></tt>) 通常要比后置自增 (<tt class="docutils literal"><span class="pre">i++</span></tt>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 <tt class="docutils literal"><span class="pre">i</span></tt> 进行一次拷贝. 如果 <tt class="docutils literal"><span class="pre">i</span></tt> 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</dd>
<dt>缺点:</dt>
<dd>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 <tt class="docutils literal"><span class="pre">for</span></tt> 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (<tt class="docutils literal"><span class="pre">i</span></tt>) 在谓语动词 (<tt class="docutils literal"><span class="pre">++</span></tt>) 前.</dd>
<dt>结论:</dt>
<dd>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</dd>
</dl>
</div>
<div class="section" id="const">
<h4>5.11. <tt class="docutils literal"><span class="pre">const</span></tt> 的使用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们强烈建议你在任何可能的情况下都要使用 <tt class="docutils literal"><span class="pre">const</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>在声明的变量或参数前加上关键字 <tt class="docutils literal"><span class="pre">const</span></tt> 用于指明变量值不可被篡改 (如 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">foo</span></tt> ). 为类中的函数加上 <tt class="docutils literal"><span class="pre">const</span></tt> 限定符表明该函数不会修改类成员变量的状态 (如 <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Foo</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">Bar(char</span> <span class="pre">c)</span> <span class="pre">const;</span> <span class="pre">};</span></tt>).</dd>
<dt>优点:</dt>
<dd>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</dd>
<dt>缺点:</dt>
<dd><tt class="docutils literal"><span class="pre">const</span></tt> 是入侵性的: 如果你向一个函数传入 <tt class="docutils literal"><span class="pre">const</span></tt> 变量, 函数原型声明中也必须对应 <tt class="docutils literal"><span class="pre">const</span></tt> 参数 (否则变量需要 <tt class="docutils literal"><span class="pre">const_cast</span></tt> 类型转换), 在调用库函数时显得尤其麻烦.</dd>
<dt>结论:</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">const</span></tt> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 <tt class="docutils literal"><span class="pre">const</span></tt>:</p>
<blockquote>
<div><ul class="simple">
<li>如果函数不会修改传入的引用或指针类型参数, 该参数应声明为 <tt class="docutils literal"><span class="pre">const</span></tt>.</li>
<li>尽可能将函数声明为 <tt class="docutils literal"><span class="pre">const</span></tt>. 访问函数应该总是 <tt class="docutils literal"><span class="pre">const</span></tt>. 其他不会修改任何数据成员, 未调用非 <tt class="docutils literal"><span class="pre">const</span></tt> 函数, 不会返回数据成员非 <tt class="docutils literal"><span class="pre">const</span></tt> 指针或引用的函数也应该声明成 <tt class="docutils literal"><span class="pre">const</span></tt>.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <tt class="docutils literal"><span class="pre">const</span></tt>.</li>
</ul>
</div></blockquote>
<p>然而, 也不要发了疯似的使用 <tt class="docutils literal"><span class="pre">const</span></tt>. 像 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">x;</span></tt> 就有些过了, 虽然它非常精确的描述了常量 <tt class="docutils literal"><span class="pre">x</span></tt>. 关注真正有帮助意义的信息: 前面的例子写成 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int**</span> <span class="pre">x</span></tt> 就够了.</p>
<p class="last">关键字 <tt class="docutils literal"><span class="pre">mutable</span></tt> 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">const</span></tt> 的位置:</dt>
<dd><p class="first">有人喜欢 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">const</span> <span class="pre">*foo</span></tt> 形式, 不喜欢 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">foo</span></tt>, 他们认为前者更一致因此可读性也更好: 遵循了 <tt class="docutils literal"><span class="pre">const</span></tt> 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, &#8220;不要过度使用&#8221; 的声明可以取消大部分你原本想保持的一致性. 将 <tt class="docutils literal"><span class="pre">const</span></tt> 放在前面才更易读, 因为在自然语言中形容词 (<tt class="docutils literal"><span class="pre">const</span></tt>) 是在名词 (<tt class="docutils literal"><span class="pre">int</span></tt>) 之前.</p>
<p class="last">这是说, 我们提倡但不强制 <tt class="docutils literal"><span class="pre">const</span></tt> 在前. 但要保持代码的一致性! (yospaly 注: 也就是不要在一些地方把 <tt class="docutils literal"><span class="pre">const</span></tt> 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)</p>
</dd>
</dl>
</div>
<div class="section" id="id13">
<h4>5.12. 整型</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">C++ 内建整型中, 仅使用 <tt class="docutils literal"><span class="pre">int</span></tt>. 如果程序中需要不同大小的变量, 可以使用 <tt class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></tt> 中长度精确的整型, 如 <tt class="docutils literal"><span class="pre">int16_t</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>C++ 没有指定整型的大小. 通常人们假定 <tt class="docutils literal"><span class="pre">short</span></tt> 是 16 位, <tt class="docutils literal"><span class="pre">int``是</span> <span class="pre">32</span> <span class="pre">位,</span> <span class="pre">``long</span></tt> 是 32 位, <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> 是 64 位.</dd>
<dt>优点:</dt>
<dd>保持声明统一.</dd>
<dt>缺点:</dt>
<dd>C++ 中整型大小因编译器和体系结构的不同而不同.</dd>
<dt>结论:</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></tt> 定义了 <tt class="docutils literal"><span class="pre">int16_t</span></tt>, <tt class="docutils literal"><span class="pre">uint32_t</span></tt>, <tt class="docutils literal"><span class="pre">int64_t</span></tt> 等整型, 在需要确保整型大小时可以使用它们代替 <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt> 等. 在 C 整型中, 只使用 <tt class="docutils literal"><span class="pre">int</span></tt>. 在合适的情况下, 推荐使用标准类型如 <tt class="docutils literal"><span class="pre">size_t</span></tt> 和 <tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt>.</p>
<p>如果已知整数不会太大, 我们常常会使用 <tt class="docutils literal"><span class="pre">int</span></tt>, 如循环计数. 在类似的情况下使用原生类型 <tt class="docutils literal"><span class="pre">int</span></tt>. 你可以认为 <tt class="docutils literal"><span class="pre">int</span></tt> 至少为 32 位, 但不要认为它会多于 <tt class="docutils literal"><span class="pre">32</span></tt> 位. 如果需要 64 位整型, 用 <tt class="docutils literal"><span class="pre">int64_t</span></tt> 或 <tt class="docutils literal"><span class="pre">uint64_t</span></tt>.</p>
<p>对于大整数, 使用 <tt class="docutils literal"><span class="pre">int64_t</span></tt>.</p>
<p class="last">不要使用 <tt class="docutils literal"><span class="pre">uint32_t</span></tt> 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p>
</dd>
<dt>关于无符号整数:</dt>
<dd><dl class="first docutils">
<dt>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">Length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
</dd>
</dl>
<p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p class="last">因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p>
</dd>
</dl>
</div>
<div class="section" id="id14">
<h4>5.13. 64 位下的可移植性</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:</p>
</div>
<ul>
<li><p class="first">对于某些类型, <tt class="docutils literal"><span class="pre">printf()</span></tt> 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 <tt class="docutils literal"><span class="pre">inttypes.h</span></tt> 仿标准风格):</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// printf macros for size_t, in the style of inttypes.h</span>
<span class="cp">#ifdef _LP64</span>
<span class="cp">#define __PRIS_PREFIX &quot;z&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define __PRIS_PREFIX</span>
<span class="cp">#endif</span>

<span class="c1">// Use these macros after a % in a printf format string</span>
<span class="c1">// to get correct 32/64 bit behavior, like this:</span>
<span class="c1">// size_t size = records.size();</span>
<span class="c1">// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);</span>
<span class="cp">#define PRIdS __PRIS_PREFIX &quot;d&quot;</span>
<span class="cp">#define PRIxS __PRIS_PREFIX &quot;x&quot;</span>
<span class="cp">#define PRIuS __PRIS_PREFIX &quot;u&quot;</span>
<span class="cp">#define PRIXS __PRIS_PREFIX &quot;X&quot;</span>
<span class="cp">#define PRIoS __PRIS_PREFIX &quot;o&quot;</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="25%" />
<col width="31%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">类型</p>
</th>
<th class="head"><p class="first last">不要使用</p>
</th>
<th class="head"><p class="first last">使用</p>
</th>
<th class="head"><p class="first last">备注</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><p class="first last"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt>
(或其他指针类型)</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%lx</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%p</span></tt></p>
</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><p class="first last"><tt class="docutils literal"><span class="pre">int64_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%qd,</span> <span class="pre">%lld</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRId64&quot;</span></tt></p>
</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><p class="first last"><tt class="docutils literal"><span class="pre">uint64_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%qu,</span> <span class="pre">%llu,</span> <span class="pre">%llx</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRIu64&quot;,</span> <span class="pre">%&quot;PRIx64&quot;</span></tt></p>
</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><p class="first last"><tt class="docutils literal"><span class="pre">size_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%u</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRIuS&quot;,</span> <span class="pre">%&quot;PRIxS&quot;</span></tt></p>
</td>
<td><p class="first last">C99 规定 <tt class="docutils literal"><span class="pre">%zu</span></tt></p>
</td>
</tr>
<tr class="row-even"><td><p class="first last"><tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%d</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRIdS&quot;</span></tt></p>
</td>
<td><p class="first last">C99 规定 <tt class="docutils literal"><span class="pre">%zd</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>注意 <tt class="docutils literal"><span class="pre">PRI*</span></tt> 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 <tt class="docutils literal"><span class="pre">PRI*</span></tt> 宏同样可以在 <tt class="docutils literal"><span class="pre">%</span></tt> 后包含长度指示符. 例如, <tt class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;PRIuS&quot;\n&quot;,</span> <span class="pre">x)</span></tt> 在 32 位 Linux 上将被展开为 <tt class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;</span> <span class="pre">&quot;u&quot;</span> <span class="pre">&quot;\n&quot;,</span> <span class="pre">x)</span></tt>, 编译器当成 <tt class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30u\n&quot;,</span> <span class="pre">x)</span></tt> 处理 (yospaly 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p>
</div></blockquote>
</li>
<li><p class="first">记住 <tt class="docutils literal"><span class="pre">sizeof(void</span> <span class="pre">*)</span> <span class="pre">!=</span> <span class="pre">sizeof(int)</span></tt>. 如果需要一个指针大小的整数要用 <tt class="docutils literal"><span class="pre">intptr_t</span></tt>.</p>
</li>
<li><p class="first">你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (yospaly 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 <tt class="docutils literal"><span class="pre">int64_t</span></tt>/<tt class="docutils literal"><span class="pre">uint64_t</span></tt> 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 <tt class="docutils literal"><span class="pre">__attribute__((packed))</span></tt>. MSVC 则提供了 <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack()</span></tt> 和 <tt class="docutils literal"><span class="pre">__declspec(align())</span></tt> (YuleFox 注, 解决方案的项目属性里也可以直接设置).</p>
</li>
<li><dl class="first docutils">
<dt>创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:</dt>
<dd><div class="first last highlight-c++"><pre>int64_t my_value = 0×123456789LL;
uint64_t my_mask = 3ULL &lt;&lt; 48;</pre>
</div>
</dd>
</dl>
</li>
<li><p class="first">如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 <tt class="docutils literal"><span class="pre">#ifdef</span> <span class="pre">_LP64</span></tt> 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)</p>
</li>
</ul>
</div>
<div class="section" id="preprocessor-macros">
<span id="id15"></span><h4>5.14. 预处理宏</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
</div>
<p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</p>
<p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 <tt class="docutils literal"><span class="pre">const</span></tt> 变量代替. 用宏 &#8220;缩写&#8221; 长变量名可被引用代替. 用宏进行条件编译... 这个, 千万别这么做, 会令测试更加痛苦 (<tt class="docutils literal"><span class="pre">#define</span></tt> 防止头文件重包含当然是个特例).</p>
<p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 <tt class="docutils literal"><span class="pre">#</span></tt> 字符串化, 用 <tt class="docutils literal"><span class="pre">##</span></tt> 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p>
<p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:</p>
<blockquote>
<div><ul class="simple">
<li>不要在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中定义宏.</li>
<li>在马上要使用时才进行 <tt class="docutils literal"><span class="pre">#define</span></tt>, 使用后要立即 <tt class="docutils literal"><span class="pre">#undef</span></tt>.</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="null">
<h4>5.15. 0 和 NULL</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">整数用 <tt class="docutils literal"><span class="pre">0</span></tt>, 实数用 <tt class="docutils literal"><span class="pre">0.0</span></tt>, 指针用 <tt class="docutils literal"><span class="pre">NULL</span></tt>, 字符 (串) 用 <tt class="docutils literal"><span class="pre">'\0'</span></tt>.</p>
</div>
<p>整数用 <tt class="docutils literal"><span class="pre">0</span></tt>, 实数用 <tt class="docutils literal"><span class="pre">0.0</span></tt>, 这一点是毫无争议的.</p>
<p>对于指针 (地址值), 到底是用 <tt class="docutils literal"><span class="pre">0</span></tt> 还是 <tt class="docutils literal"><span class="pre">NULL</span></tt>, Bjarne Stroustrup 建议使用最原始的 <tt class="docutils literal"><span class="pre">0</span></tt>. 我们建议使用看上去像是指针的 <tt class="docutils literal"><span class="pre">NULL</span></tt>, 事实上一些 C++ 编译器 (如 gcc 4.1.0) 对 <tt class="docutils literal"><span class="pre">NULL</span></tt> 进行了特殊的定义, 可以给出有用的警告信息, 尤其是 <tt class="docutils literal"><span class="pre">sizeof(NULL)</span></tt> 和 <tt class="docutils literal"><span class="pre">sizeof(0)</span></tt> 不相等的情况.</p>
<p>字符 (串) 用 <tt class="docutils literal"><span class="pre">'\0'</span></tt>, 不仅类型正确而且可读性好.</p>
</div>
<div class="section" id="sizeof">
<h4>5.16. sizeof</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能用 <tt class="docutils literal"><span class="pre">sizeof(varname)</span></tt> 代替 <tt class="docutils literal"><span class="pre">sizeof(type)</span></tt>.</p>
</div>
<dl class="docutils">
<dt>使用 <tt class="docutils literal"><span class="pre">sizeof(varname)</span></tt> 是因为当代码中变量类型改变时会自动更新. 某些情况下 <tt class="docutils literal"><span class="pre">sizeof(type)</span></tt> 或许有意义, 但还是要尽量避免, 因为它会导致变量类型改变后不能同步.</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="n">Struct</span> <span class="n">data</span><span class="p">;</span>
<span class="n">Struct</span> <span class="n">data</span><span class="p">;</span> <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Struct</span><span class="p">));</span>
</pre></div>
</div>
</div>
</dd>
</dl>
</div>
<div class="section" id="boost">
<h4>5.17. Boost 库</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用 Boost 中被认可的库.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><a class="reference external" href="http://www.boost.org/">Boost 库集</a> 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集.</dd>
<dt>优点:</dt>
<dd>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针, 同时还提供了 <tt class="docutils literal"><span class="pre">TR1</span></tt> (标准库扩展) 的实现.</dd>
<dt>缺点:</dt>
<dd>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 &#8220;函数化&#8221; 的编程风格.</dd>
<dt>结论:</dt>
<dd><p class="first">为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库:</p>
<blockquote class="last">
<div><ul class="simple">
<li><a class="reference external" href="http://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair</a> : <tt class="docutils literal"><span class="pre">boost/compressed_pair.hpp</span></tt></li>
<li><a class="reference external" href="http://www.boost.org/libs/ptr_container/">Pointer Container</a> : <tt class="docutils literal"><span class="pre">boost/ptr_container</span></tt> (序列化除外)</li>
<li><a class="reference external" href="http://www.boost.org/libs/array/">Array</a> : <tt class="docutils literal"><span class="pre">boost/array.hpp</span></tt></li>
<li><a class="reference external" href="http://www.boost.org/libs/graph/">The Boost Graph Library (BGL)</a> : <tt class="docutils literal"><span class="pre">boost/graph</span></tt> (序列化除外)</li>
<li><a class="reference external" href="http://www.boost.org/libs/property_map/">Property Map</a> : <tt class="docutils literal"><span class="pre">boost/property_map.hpp</span></tt></li>
<li><a class="reference external" href="http://www.boost.org/libs/iterator/">Iterator</a> 中处理迭代器定义的部分 : <tt class="docutils literal"><span class="pre">boost/iterator/iterator_adaptor.hpp</span></tt>, <tt class="docutils literal"><span class="pre">boost/iterator/iterator_facade.hpp</span></tt>, 以及 <tt class="docutils literal"><span class="pre">boost/function_output_iterator.hpp</span></tt></li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p>
</div>
</div>
<span id="document-google-cpp-styleguide/naming"></span><div class="section" id="id1">
<h3>6. 命名约定</h3>
<p>最重要的一致性规则是命名管理. 命名风格快速获知名字代表是什么东东: 类型? 变量? 函数? 常量? 宏 ... ? 甚至不需要去查找类型声明. 我们大脑中的模式匹配引擎可以非常可靠的处理这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重, 所以不管你怎么想, 规则总归是规则.</p>
<div class="section" id="id2">
<h4>6.1. 通用命名规则</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">函数命名, 变量命名, 文件命名应具备描述性; 不要过度缩写. 类型和变量应该是名词, 函数名可以用 &#8220;命令性&#8221; 动词.</p>
</div>
<dl class="docutils">
<dt>如何命名:</dt>
<dd><dl class="first docutils">
<dt>尽可能给出描述性的名称. 不要节约行空间, 让别人很快理解你的代码更重要. 好的命名风格:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">num_errors</span><span class="p">;</span>                  <span class="c1">// Good.</span>
<span class="kt">int</span> <span class="n">num_completed_connections</span><span class="p">;</span>   <span class="c1">// Good.</span>
</pre></div>
</div>
</dd>
<dt>糟糕的命名使用含糊的缩写或随意的字符:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                           <span class="c1">// Bad - meaningless.</span>
<span class="kt">int</span> <span class="n">nerr</span><span class="p">;</span>                        <span class="c1">// Bad - ambiguous abbreviation.</span>
<span class="kt">int</span> <span class="n">n_comp_conns</span><span class="p">;</span>                <span class="c1">// Bad - ambiguous abbreviation.</span>
</pre></div>
</div>
</dd>
</dl>
<p>类型和变量名一般为名词: 如 <tt class="docutils literal"><span class="pre">FileOpener</span></tt>, <tt class="docutils literal"><span class="pre">num_errors</span></tt>.</p>
<p class="last">函数名通常是指令性的 (确切的说它们应该是命令), 如 <tt class="docutils literal"><span class="pre">OpenFile()</span></tt>, <tt class="docutils literal"><span class="pre">set_num_errors()</span></tt>. 取值函数是个特例 (在 <a class="reference internal" href="contents.html#function-names"><em>函数命名</em></a> 处详细阐述), 函数名和它要取值的变量同名.</p>
</dd>
<dt>缩写:</dt>
<dd><dl class="first last docutils">
<dt>除非该缩写在其它地方都非常普遍, 否则不要使用. 例如:</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="c1">// Good</span>
<span class="c1">// These show proper names with no abbreviations.</span>
<span class="kt">int</span> <span class="n">num_dns_connections</span><span class="p">;</span>  <span class="c1">// 大部分人都知道 &quot;DNS&quot; 是啥意思.</span>
<span class="kt">int</span> <span class="n">price_count_reader</span><span class="p">;</span>   <span class="c1">// OK, price count. 有意义.</span>
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// Bad!</span>
<span class="c1">// Abbreviations can be confusing or ambiguous outside a small group.</span>
<span class="kt">int</span> <span class="n">wgc_connections</span><span class="p">;</span>  <span class="c1">// Only your group knows what this stands for.</span>
<span class="kt">int</span> <span class="n">pc_reader</span><span class="p">;</span>        <span class="c1">// Lots of things can be abbreviated &quot;pc&quot;.</span>
</pre></div>
</div>
</div>
</dd>
<dt>永远不要用省略字母的缩写:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">error_count</span><span class="p">;</span>  <span class="c1">// Good.</span>
<span class="kt">int</span> <span class="n">error_cnt</span><span class="p">;</span>    <span class="c1">// Bad.</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="id3">
<h4>6.2. 文件命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">文件名要全部小写, 可以包含下划线 (<tt class="docutils literal"><span class="pre">_</span></tt>) 或连字符 (<tt class="docutils literal"><span class="pre">-</span></tt>). 按项目约定来.</p>
</div>
<p>可接受的文件命名:</p>
<div class="highlight-python"><pre>my_useful_class.cc
my-useful-class.cc
myusefulclass.cc</pre>
</div>
<p>C++ 文件要以 <tt class="docutils literal"><span class="pre">.cc</span></tt> 结尾, 头文件以 <tt class="docutils literal"><span class="pre">.h</span></tt> 结尾.</p>
<p>不要使用已经存在于 <tt class="docutils literal"><span class="pre">/usr/include</span></tt> 下的文件名 (yospaly 注: 即编译器搜索系统头文件的路径), 如 <tt class="docutils literal"><span class="pre">db.h</span></tt>.</p>
<p>通常应尽量让文件名更加明确. <tt class="docutils literal"><span class="pre">http_server_logs.h</span></tt> 就比 <tt class="docutils literal"><span class="pre">logs.h</span></tt> 要好. 定义类时文件名一般成对出现, 如 <tt class="docutils literal"><span class="pre">foo_bar.h</span></tt> 和 <tt class="docutils literal"><span class="pre">foo_bar.cc</span></tt>, 对应于类 <tt class="docutils literal"><span class="pre">FooBar</span></tt>.</p>
<p>内联函数必须放在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中. 如果内联函数比较短, 就直接放在 <tt class="docutils literal"><span class="pre">.h</span></tt> 中. 如果代码比较长, 可以放到以 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 结尾的文件中. 对于包含大量内联代码的类, 可以使用三个文件:</p>
<div class="highlight-python"><pre>url_table.h      // The class declaration.
url_table.cc     // The class definition.
url_table-inl.h  // Inline functions that include lots of code.</pre>
</div>
<p>参考 <a class="reference internal" href="contents.html#inl-files"><em>-inl.h 文件</em></a> 一节.</p>
</div>
<div class="section" id="id4">
<h4>6.3. 类型命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类型名称的每个单词首字母均大写, 不包含下划线: <tt class="docutils literal"><span class="pre">MyExcitingClass</span></tt>, <tt class="docutils literal"><span class="pre">MyExcitingEnum</span></tt>.</p>
</div>
<dl class="docutils">
<dt>所有类型命名 —— 类, 结构体, 类型定义 (<tt class="docutils literal"><span class="pre">typedef</span></tt>), 枚举 —— 均使用相同约定. 例如:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="c1">// classes and structs</span>
<span class="k">class</span> <span class="nc">UrlTable</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">class</span> <span class="nc">UrlTableTester</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">struct</span> <span class="n">UrlTableProperties</span> <span class="p">{</span> <span class="p">...</span>

<span class="c1">// typedefs</span>
<span class="k">typedef</span> <span class="n">hash_map</span><span class="o">&lt;</span><span class="n">UrlTableProperties</span> <span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">PropertiesMap</span><span class="p">;</span>

<span class="c1">// enums</span>
<span class="k">enum</span> <span class="n">UrlTableErrors</span> <span class="p">{</span> <span class="p">...</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h4>6.4. 变量命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 如:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">my_exciting_local_variable</span>
<span class="n">my_exciting_member_variable_</span>
</pre></div>
</div>
</div>
<dl class="docutils">
<dt>普通变量命名:</dt>
<dd><p class="first">举例:</p>
<div class="highlight-python"><pre>string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.</pre>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>   <span class="c1">// Bad - mixed case.</span>
</pre></div>
</div>
</div>
</dd>
<dt>结构体变量:</dt>
<dd><dl class="first docutils">
<dt>结构体的数据成员可以和普通变量一样, 不用像类那样接下划线:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">UrlTableProperties</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
<p class="last">结构体与类的讨论参考 <a class="reference internal" href="contents.html#structs-vs-classes"><em>结构体 vs. 类</em></a> 一节.</p>
</dd>
<dt>全局变量:</dt>
<dd>对全局变量没有特别要求, 少用就好, 但如果你要用, 可以用 <tt class="docutils literal"><span class="pre">g_</span></tt> 或其它标志作为前缀, 以便更好的区分局部变量.</dd>
</dl>
</div>
<div class="section" id="constant-names">
<span id="id6"></span><h4>6.5. 常量命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在名称前加 <tt class="docutils literal"><span class="pre">k</span></tt>: kDaysInAWeek.</p>
</div>
<dl class="docutils">
<dt>所有编译时常量, 无论是局部的, 全局的还是类中的, 和其他变量稍微区别一下. <tt class="docutils literal"><span class="pre">k</span></tt> 后接大写字母开头的单词::</dt>
<dd>const int kDaysInAWeek = 7;</dd>
</dl>
</div>
<div class="section" id="function-names">
<span id="id7"></span><h4>6.6. 函数命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <tt class="docutils literal"><span class="pre">MyExcitingFunction()</span></tt>, <tt class="docutils literal"><span class="pre">MyExcitingMethod()</span></tt>, <tt class="docutils literal"><span class="pre">my_exciting_member_variable()</span></tt>, <tt class="docutils literal"><span class="pre">set_my_exciting_member_variable()</span></tt>.</p>
</div>
<dl class="docutils">
<dt>常规函数:</dt>
<dd><p class="first">函数名的每个单词首字母大写, 没有下划线:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">AddTableEntry</span><span class="p">()</span>
<span class="n">DeleteUrl</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt>取值和设值函数:</dt>
<dd><dl class="first docutils">
<dt>取值和设值函数要与存取的变量名匹配. 这儿摘录一个类, <tt class="docutils literal"><span class="pre">num_entries_</span></tt> 是该类的实例变量:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="p">...</span>
        <span class="kt">int</span> <span class="n">num_entries</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">num_entries_</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">set_num_entries</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_entries</span><span class="p">)</span> <span class="p">{</span> <span class="n">num_entries_</span> <span class="o">=</span> <span class="n">num_entries</span><span class="p">;</span> <span class="p">}</span>

    <span class="nl">private:</span>
        <span class="kt">int</span> <span class="n">num_entries_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd>
</dl>
<p class="last">其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其返回值, 小写命名就可以接受.</p>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h4>6.7. 名字空间命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">名字空间用小写字母命名, 并基于项目名称和目录结构: <tt class="docutils literal"><span class="pre">google_awesome_project</span></tt>.</p>
</div>
<p>关于名字空间的讨论和如何命名, 参考 <a class="reference internal" href="contents.html#namespaces"><em>名字空间</em></a> 一节.</p>
</div>
<div class="section" id="id9">
<h4>6.8. 枚举命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">枚举的命名应当和 <a class="reference internal" href="contents.html#constant-names"><em>常量</em></a> 或 <a class="reference internal" href="contents.html#macro-names"><em>宏</em></a> 一致: <tt class="docutils literal"><span class="pre">kEnumName</span></tt> 或是 <tt class="docutils literal"><span class="pre">ENUM_NAME</span></tt>.</p>
</div>
<dl class="docutils">
<dt>单独的枚举值应该优先采用 <a class="reference internal" href="contents.html#constant-names"><em>常量</em></a> 的命名方式. 但 <a class="reference internal" href="contents.html#macro-names"><em>宏</em></a> 方式的命名也可以接受. 枚举名 <tt class="docutils literal"><span class="pre">UrlTableErrors</span></tt> (以及 <tt class="docutils literal"><span class="pre">AlternateUrlTableErrors</span></tt>) 是类型, 所以要用大小写混合的方式.</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">UrlTableErrors</span> <span class="p">{</span>
    <span class="n">kOK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">kErrorOutOfMemory</span><span class="p">,</span>
    <span class="n">kErrorMalformedInput</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="n">AlternateUrlTableErrors</span> <span class="p">{</span>
    <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">OUT_OF_MEMORY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">MALFORMED_INPUT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</dd>
</dl>
<p>2009 年 1 月之前, 我们一直建议采用 <a class="reference internal" href="contents.html#macro-names"><em>宏</em></a> 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
</div>
<div class="section" id="macro-names">
<span id="id10"></span><h4>6.9. 宏命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">你并不打算 <a class="reference internal" href="contents.html#preprocessor-macros"><em>使用宏</em></a>, 对吧? 如果你一定要用, 像这样命名: <tt class="docutils literal"><span class="pre">MY_MACRO_THAT_SCARES_SMALL_CHILDREN</span></tt>.</p>
</div>
<p>参考 <cite>预处理宏 &lt;preprocessor-macros&gt;</cite>; 通常 <em>不应该</em> 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#define ROUND(x) ...</span>
<span class="c">#define PI_ROUNDED 3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h4>6.10. 命名规则的特例</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">bigopen()</span></tt>:</dt>
<dd>函数名, 参照 <tt class="docutils literal"><span class="pre">open()</span></tt> 的形式</dd>
<dt><tt class="docutils literal"><span class="pre">uint</span></tt>:</dt>
<dd><tt class="docutils literal"><span class="pre">typedef</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">bigpos</span></tt>:</dt>
<dd><tt class="docutils literal"><span class="pre">struct</span></tt> 或 <tt class="docutils literal"><span class="pre">class</span></tt>, 参照 <tt class="docutils literal"><span class="pre">pos</span></tt> 的形式</dd>
<dt><tt class="docutils literal"><span class="pre">sparse_hash_map</span></tt>:</dt>
<dd>STL 相似实体; 参照 STL 命名约定</dd>
<dt><tt class="docutils literal"><span class="pre">LONGLONG_MAX</span></tt>:</dt>
<dd>常量, 如同 <tt class="docutils literal"><span class="pre">INT_MAX</span></tt></dd>
</dl>
</div>
</div>
<span id="document-google-cpp-styleguide/comments"></span><div class="section" id="id1">
<h3>7. 注释</h3>
<p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码本身应该是自文档化. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p>
<p>你写的注释是给代码读者看的: 下一个需要理解你的代码的人. 慷慨些吧, 下一个人可能就是你!</p>
<div class="section" id="id2">
<h4>7.1. 注释风格</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <tt class="docutils literal"><span class="pre">//</span></tt> 或 <tt class="docutils literal"><span class="pre">/*</span> <span class="pre">*/</span></tt>, 统一就好.</p>
</div>
<p><tt class="docutils literal"><span class="pre">//</span></tt> 或 <tt class="docutils literal"><span class="pre">/*</span> <span class="pre">*/</span></tt> 都可以; 但 <tt class="docutils literal"><span class="pre">//</span></tt> <em>更</em> 常用. 要在如何注释及注释风格上确保统一.</p>
</div>
<div class="section" id="id3">
<h4>7.2. 文件注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在每一个文件开头加入版权公告, 然后是文件内容描述.</p>
</div>
<dl class="docutils">
<dt>法律公告和作者信息:</dt>
<dd><p class="first">每个文件都应该包含以下项, 依次是:</p>
<blockquote>
<div><ul class="simple">
<li>版权声明 (比如, <tt class="docutils literal"><span class="pre">Copyright</span> <span class="pre">2008</span> <span class="pre">Google</span> <span class="pre">Inc.</span></tt>)</li>
<li>许可证. 为项目选择合适的许可证版本 (比如, Apache 2.0, BSD, LGPL, GPL)</li>
<li>作者: 标识文件的原始作者.</li>
</ul>
</div></blockquote>
<p class="last">如果你对原始作者的文件做了重大修改, 将你的信息添加到作者信息里. 这样当其他人对该文件有疑问时可以知道该联系谁.</p>
</dd>
<dt>文件内容:</dt>
<dd><p class="first">紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容.</p>
<p>通常, <tt class="docutils literal"><span class="pre">.h</span></tt> 文件要对所声明的类的功能和用法作简单说明. <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件通常包含了更多的实现细节或算法技巧讨论,  如果你感觉这些实现细节或算法技巧讨论对于理解 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件有帮助, 可以该注释挪到 <tt class="docutils literal"><span class="pre">.h</span></tt>, 并在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 中指出文档在 <tt class="docutils literal"><span class="pre">.h</span></tt>.</p>
<p class="last">不要简单的在 <tt class="docutils literal"><span class="pre">.h</span></tt> 和 <tt class="docutils literal"><span class="pre">.cc</span></tt> 间复制注释. 这种偏离了注释的实际意义.</p>
</dd>
</dl>
</div>
<div class="section" id="class-comments">
<span id="id4"></span><h4>7.3. 类注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个类的定义都要附带一份注释, 描述类的功能和用法.</p>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Iterates over the contents of a GargantuanTable.  Sample usage:</span>
<span class="c1">//    GargantuanTable_Iterator* iter = table-&gt;NewIterator();</span>
<span class="c1">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {</span>
<span class="c1">//      process(iter-&gt;key(), iter-&gt;value());</span>
<span class="c1">//    }</span>
<span class="c1">//    delete iter;</span>
<span class="k">class</span> <span class="nc">GargantuanTable_Iterator</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如果你觉得已经在文件顶部详细描述了该类, 想直接简单的来上一句 &#8220;完整描述见文件顶部&#8221; 也不打紧, 但务必确保有这类注释.</p>
<p>如果类有任何同步前提, 文档说明之. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
</div>
<div class="section" id="id5">
<h4>7.4. 函数注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">函数声明处注释描述函数功能; 定义处描述函数实现.</p>
</div>
<dl class="docutils">
<dt>函数声明:</dt>
<dd><p class="first">注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (&#8220;Opens the file&#8221;) 而非指令式 (&#8220;Open the file&#8221;); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>函数声明处注释的内容:</p>
<blockquote>
<div><ul class="simple">
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>如果函数分配了空间, 需要由调用者释放.</li>
<li>参数是否可以为 <tt class="docutils literal"><span class="pre">NULL</span></tt>.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ul>
</div></blockquote>
<p>举例如下:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Returns an iterator for this table.  It is the client&#39;s</span>
<span class="c1">// responsibility to delete the iterator when it is done with it,</span>
<span class="c1">// and it must not use the iterator once the GargantuanTable object</span>
<span class="c1">// on which the iterator was created has been deleted.</span>
<span class="c1">//</span>
<span class="c1">// The iterator is initially positioned at the beginning of the table.</span>
<span class="c1">//</span>
<span class="c1">// This method is equivalent to:</span>
<span class="c1">//    Iterator* iter = table-&gt;NewIterator();</span>
<span class="c1">//    iter-&gt;Seek(&quot;&quot;);</span>
<span class="c1">//    return iter;</span>
<span class="c1">// If you are going to immediately seek to another place in the</span>
<span class="c1">// returned iterator, it will be faster to use NewIterator()</span>
<span class="c1">// and avoid the extra seek.</span>
<span class="n">Iterator</span><span class="o">*</span> <span class="n">GetIterator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>但也要避免罗罗嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 &#8220;returns false otherwise&#8221;, 因为已经暗含其中了:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Returns true if the table cannot hold any more entries.</span>
<span class="kt">bool</span> <span class="nf">IsTableFull</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
<p class="last">注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 &#8220;destroys this object&#8221; 这样的注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
</dd>
<dt>函数定义:</dt>
<dd><p class="first">每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.</p>
<p class="last"><em>不要</em> 从 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
</dd>
</dl>
</div>
<div class="section" id="id6">
<h4>7.5. 变量注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
</div>
<dl class="docutils">
<dt>类数据成员:</dt>
<dd><p class="first">每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 <tt class="docutils literal"><span class="pre">NULL</span></tt> 或 <tt class="docutils literal"><span class="pre">-1</span></tt> 等警戒值, 须加以说明. 比如:</p>
<blockquote class="last">
<div><div class="highlight-c++"><div class="highlight"><pre><span class="nl">private:</span>
    <span class="c1">// Keeps track of the total number of entries in the table.</span>
    <span class="c1">// Used to ensure we do not go over the limit. -1 means</span>
    <span class="c1">// that we don&#39;t yet know how many entries the table has.</span>
    <span class="kt">int</span> <span class="n">num_total_entries_</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</dd>
<dt>全局变量:</dt>
<dd><p class="first">和数据成员一样, 所有全局变量也要注释说明含义及用途. 比如:</p>
<blockquote class="last">
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// The total number of tests cases that we run through in this regression test.</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">kNumTestCases</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h4>7.6. 实现注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
</div>
<dl class="docutils">
<dt>代码前注释:</dt>
<dd><p class="first">巧妙或复杂的代码段前要加注释. 比如:</p>
<blockquote class="last">
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Divide result by two, taking into account that x</span>
<span class="c1">// contains the carry from the add.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">&amp;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</dd>
<dt>行注释:</dt>
<dd><p class="first">比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// If we have enough memory, mmap the data portion too.</span>
<span class="n">mmap_budget</span> <span class="o">=</span> <span class="n">max</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmap_budget</span> <span class="o">-</span> <span class="n">index_</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mmap_budget</span> <span class="o">&gt;=</span> <span class="n">data_size_</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">MmapData</span><span class="p">(</span><span class="n">mmap_chunk_bytes</span><span class="p">,</span> <span class="n">mlock</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>  <span class="c1">// Error already logged.</span>
</pre></div>
</div>
</div></blockquote>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
<blockquote class="last">
<div><div class="highlight-c++"><div class="highlight"><pre><span class="n">DoSomething</span><span class="p">();</span>                  <span class="c1">// Comment here so the comments line up.</span>
<span class="n">DoSomethingElseThatIsLonger</span><span class="p">();</span>  <span class="c1">// Comment here so there are two spaces between</span>
                                <span class="c1">// the code and the comment.</span>
<span class="p">{</span> <span class="c1">// One space before comment when opening a new scope is allowed,</span>
  <span class="c1">// thus the comment lines up with the following comments and code.</span>
  <span class="n">DoSomethingElse</span><span class="p">();</span>  <span class="c1">// Two spaces before line comments normally.</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</dd>
<dt>NULL, true/false, 1, 2, 3...:</dt>
<dd><p class="first">向函数传入 <tt class="docutils literal"><span class="pre">NULL</span></tt>, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意. 例如, 对比:</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">CalculateSomething</span><span class="p">(</span><span class="n">interesting_value</span><span class="p">,</span>
                                  <span class="mi">10</span><span class="p">,</span>
                                  <span class="nb">false</span><span class="p">,</span>
                                  <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// What are these arguments??</span>
</pre></div>
</div>
</div>
</div></blockquote>
<p>和:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">CalculateSomething</span><span class="p">(</span><span class="n">interesting_value</span><span class="p">,</span>
                                  <span class="mi">10</span><span class="p">,</span>     <span class="c1">// Default base value.</span>
                                  <span class="nb">false</span><span class="p">,</span>  <span class="c1">// Not the first time we&#39;re calling this.</span>
                                  <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// No callback.</span>
</pre></div>
</div>
</div></blockquote>
<p>或使用常量或描述性变量:</p>
<blockquote class="last">
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">kDefaultBaseValue</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">bool</span> <span class="n">kFirstTimeCalling</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">Callback</span> <span class="o">*</span><span class="n">null_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">CalculateSomething</span><span class="p">(</span><span class="n">interesting_value</span><span class="p">,</span>
                                  <span class="n">kDefaultBaseValue</span><span class="p">,</span>
                                  <span class="n">kFirstTimeCalling</span><span class="p">,</span>
                                  <span class="n">null_callback</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</dd>
<dt>不允许:</dt>
<dd><p class="first">注意 <em>永远不要</em> 用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// 现在, 检查 b 数组并确保 i 是否存在,</span>
<span class="c1">// 下一个元素是 i+1.</span>
<span class="p">...</span>        <span class="c1">// 天哪. 令人崩溃的注释.</span>
</pre></div>
</div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h4>7.7. 标点, 拼写和语法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
</div>
<p>注释的通常写法是包含正确大小写和结尾句号的完整语句. 短一点的注释 (如代码行尾注释) 可以随意点, 依然要注意风格的一致性. 完整的语句可读性更好, 也可以说明该注释是完整的, 而不是一些不成熟的想法.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有所帮助.</p>
</div>
<div class="section" id="todo">
<h4>7.8. TODO 注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <tt class="docutils literal"><span class="pre">TODO</span></tt> 注释.</p>
</div>
<p><tt class="docutils literal"><span class="pre">TODO</span></tt> 注释要使用全大写的字符串 <tt class="docutils literal"><span class="pre">TODO</span></tt>, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <tt class="docutils literal"><span class="pre">TODO</span></tt> 格式进行查找. 添加 <tt class="docutils literal"><span class="pre">TODO</span></tt> 注释并不意味着你要自己来修正.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span>
<span class="c1">// TODO(Zeke) change this to use relations.</span>
</pre></div>
</div>
</div></blockquote>
<p>如果加 <tt class="docutils literal"><span class="pre">TODO</span></tt> 是为了在 &#8220;将来某一天做某事&#8221;, 可以附上一个非常明确的时间 &#8220;Fix by November 2005&#8221;), 或者一个明确的事项 (&#8220;Remove this code when all clients can handle XML responses.&#8221;).</p>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>关于注释风格，很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/formatting"></span><div class="section" id="id1">
<h3>8. 格式</h3>
<p>代码风格和格式确实比较随意, 但一个项目中所有人遵循同一风格是非常容易的. 个体未必同意下述每一处格式规则, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人能很轻松的阅读和理解代码.</p>
<p>另外, 我们写了一个 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el">emacs 配置文件</a> 来帮助你正确的格式化代码.</p>
<div class="section" id="line-length">
<span id="id2"></span><h4>8.1. 行长度</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每一行代码字符数不超过 80.</p>
</div>
<p>我们也认识到这条规则是有争议的, 但很多已有代码都已经遵照这一规则, 我们感觉一致性更重要.</p>
<dl class="docutils">
<dt>优点:</dt>
<dd>提倡该原则的人主张强迫他们调整编辑器窗口大小很野蛮. 很多人同时并排开几个代码窗口, 根本没有多余空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 为什么要改变呢?</dd>
<dt>缺点:</dt>
<dd>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 很轻松的可以显示更多代码.</dd>
<dt>结论:</dt>
<dd><p class="first">80 个字符是最大值.</p>
<p>特例:</p>
<ul class="last simple">
<li>如果一行注释包含了超过 80 字符的命令或 URL, 出于复制粘贴的方便允许该行超过 80 字符.</li>
<li>包含长路径的 <tt class="docutils literal"><span class="pre">#include</span></tt> 语句可以超出80列. 但应该尽量避免.</li>
<li><a class="reference internal" href="contents.html#define-guard"><em>头文件保护</em></a> 可以无视该原则.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="ascii">
<h4>8.2. 非 ASCII 字符</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
</div>
<p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符要少用. 特殊情况下可以适当包含此类字符. 如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码. 十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 <tt class="docutils literal"><span class="pre">&quot;\xEF\xBB\xBF&quot;</span></tt> 在 Unicode 中是 <em>零宽度 无间断</em> 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的. (yospaly 注: <tt class="docutils literal"><span class="pre">&quot;\xEF\xBB\xBF&quot;</span></tt> 通常用作 UTF-8 with BOM 编码标记)</p>
</div>
<div class="section" id="id3">
<h4>8.3. 空格还是制表位</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用空格, 每次缩进 2 个空格.</p>
</div>
<p>我们使用空格缩进. 不要在代码中使用制符表. 你应该设置编辑器将制符表转为空格.</p>
</div>
<div class="section" id="id4">
<h4>8.4. 函数声明与定义</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">返回类型和函数名在同一行, 参数也尽量放在同一行.</p>
</div>
<dl class="docutils">
<dt>函数看上去像这样:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">ReturnType</span> <span class="n">ClassName</span><span class="o">::</span><span class="n">FunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span> <span class="n">Type</span> <span class="n">par_name2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>如果同一行文本太多, 放不下所有参数:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">ReturnType</span> <span class="n">ClassName</span><span class="o">::</span><span class="n">ReallyLongFunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span>
                                             <span class="n">Type</span> <span class="n">par_name2</span><span class="p">,</span>
                                             <span class="n">Type</span> <span class="n">par_name3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>甚至连第一个参数都放不下:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">ReturnType</span> <span class="n">LongClassName</span><span class="o">::</span><span class="n">ReallyReallyReallyLongFunctionName</span><span class="p">(</span>
        <span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span>  <span class="c1">// 4 space indent</span>
        <span class="n">Type</span> <span class="n">par_name2</span><span class="p">,</span>
        <span class="n">Type</span> <span class="n">par_name3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 space indent</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>注意以下几点:</p>
<blockquote>
<div><ul class="simple">
<li>返回值总是和函数名在同一行;</li>
<li>左圆括号总是和函数名在同一行;</li>
<li>函数名和左圆括号间没有空格;</li>
<li>圆括号与参数间没有空格;</li>
<li>左大括号总在最后一个参数同一行的末尾处;</li>
<li>右大括号总是单独位于函数最后一行;</li>
<li>右圆括号和左大括号间总是有一个空格;</li>
<li>函数声明和实现处的所有形参名称必须保持一致;</li>
<li>所有形参应尽可能对齐;</li>
<li>缺省缩进为 2 个空格;</li>
<li>换行后的参数保持 4 个空格的缩进;</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>如果函数声明成 <tt class="docutils literal"><span class="pre">const</span></tt>, 关键字 <tt class="docutils literal"><span class="pre">const</span></tt> 应与最后一个参数位于同一行:=</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="c1">// Everything in this function signature fits on a single line</span>
<span class="n">ReturnType</span> <span class="n">FunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// This function signature requires multiple lines, but</span>
<span class="c1">// the const keyword is on the line with the last parameter.</span>
<span class="n">ReturnType</span> <span class="n">ReallyLongFunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par1</span><span class="p">,</span>
                                  <span class="n">Type</span> <span class="n">par2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>如果有些参数没有用到, 在函数定义处将参数名注释起来:</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="c1">// Always have named parameters in interfaces.</span>
<span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="n">radians</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Always have named parameters in the declaration.</span>
<span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="n">radians</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Comment out unused named parameters in definitions.</span>
<span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="cm">/*radians*/</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// Bad - if someone wants to implement later, it&#39;s not clear what the</span>
<span class="c1">// variable means.</span>
<span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h4>8.5. 函数调用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽量放在同一行, 否则, 将实参封装在圆括号中.</p>
</div>
<dl class="docutils">
<dt>函数调用遵循如下形式:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argument3</span><span class="p">);</span>
</pre></div>
</div>
</dd>
<dt>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">averyveryveryverylongargument1</span><span class="p">,</span>
                          <span class="n">argument2</span><span class="p">,</span> <span class="n">argument3</span><span class="p">);</span>
</pre></div>
</div>
</dd>
<dt>如果函数参数很多, 出于可读性的考虑可以在每行只放一个参数:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span>
                          <span class="n">argument2</span><span class="p">,</span>
                          <span class="n">argument3</span><span class="p">,</span>
                          <span class="n">argument4</span><span class="p">);</span>
</pre></div>
</div>
</dd>
<dt>如果函数名非常长, 以至于超过 <a class="reference internal" href="contents.html#line-length"><em>行最大长度</em></a>, 可以将所有参数独立成行:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">DoSomethingThatRequiresALongFunctionName</span><span class="p">(</span>
        <span class="n">very_long_argument1</span><span class="p">,</span>  <span class="c1">// 4 space indent</span>
        <span class="n">argument2</span><span class="p">,</span>
        <span class="n">argument3</span><span class="p">,</span>
        <span class="n">argument4</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id6">
<h4>8.6. 条件语句</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">倾向于不在圆括号内使用空格. 关键字 <tt class="docutils literal"><span class="pre">else</span></tt> 另起一行.</p>
</div>
<p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<dl class="docutils">
<dt>最常见的是没有空格的格式. 哪种都可以, 但 <em>保持一致性</em>. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在徘徊的话, 就不要加空格了.</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// no spaces inside parentheses</span>
  <span class="p">...</span>  <span class="c1">// 2 space indent.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// The else goes on the same line as the closing brace.</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>如果你更喜欢在圆括号内部加空格:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span> <span class="n">condition</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">// spaces inside parentheses - rare</span>
  <span class="p">...</span>  <span class="c1">// 2 space indent.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// The else goes on the same line as the closing brace.</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>注意所有情况下 <tt class="docutils literal"><span class="pre">if</span></tt> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</dt>
<dd><div class="first admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">if</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>     <span class="c1">// Bad - space missing after IF.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">){</span>   <span class="c1">// Bad - space missing before {.</span>
<span class="k">if</span><span class="p">(</span><span class="n">condition</span><span class="p">){</span>    <span class="c1">// Doubly bad.</span>
</pre></div>
</div>
</div>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Good - proper space after IF and before {.</span>
</pre></div>
</div>
</dd>
<dt>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 <tt class="docutils literal"><span class="pre">else</span></tt> 子句时使用:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">kFoo</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">kBar</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
</pre></div>
</div>
</dd>
<dt>如果语句有 <tt class="docutils literal"><span class="pre">else</span></tt> 分支则不允许:</dt>
<dd><div class="first last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// Not allowed - IF statement on one line when there is an ELSE clause</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">DoThis</span><span class="p">();</span>
<span class="k">else</span> <span class="nf">DoThat</span><span class="p">();</span>
</pre></div>
</div>
</div>
</dd>
<dt>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 <tt class="docutils literal"><span class="pre">if</span></tt> 必须总是使用大括号:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 space indent.</span>

<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 space indent.</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>但如果语句中某个 <tt class="docutils literal"><span class="pre">if-else</span></tt> 分支使用了大括号的话, 其它分支也必须使用:</dt>
<dd><div class="first admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// Not allowed - curly on IF but not ELSE</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span>
    <span class="n">bar</span><span class="p">;</span>

<span class="c1">// Not allowed - curly on ELSE but not IF</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
    <span class="n">foo</span><span class="p">;</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// Curly braces around both IF and ELSE required because</span>
<span class="c1">// one of the clauses used braces.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h4>8.7. 循环和开关选择语句</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">switch</span></tt> 语句可以使用大括号分段. 空循环体应使用 <tt class="docutils literal"><span class="pre">{}</span></tt> 或 <tt class="docutils literal"><span class="pre">continue</span></tt>.</p>
</div>
<p><tt class="docutils literal"><span class="pre">switch</span></tt> 语句中的 <tt class="docutils literal"><span class="pre">case</span></tt> 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<dl class="docutils">
<dt>如果有不满足 <tt class="docutils literal"><span class="pre">case</span></tt> 条件的枚举值, <tt class="docutils literal"><span class="pre">switch</span></tt> 应该总是包含一个 <tt class="docutils literal"><span class="pre">default</span></tt> 匹配 (如果有输入值没有 case 去处理, 编译器将报警). 如果 <tt class="docutils literal"><span class="pre">default</span></tt> 应该永远执行不到, 简单的加条 <tt class="docutils literal"><span class="pre">assert</span></tt>:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span>: <span class="p">{</span>  <span class="c1">// 2 space indent</span>
    <span class="p">...</span>      <span class="c1">// 4 space indent</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="mi">1</span>: <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nl">default:</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>空循环体应使用 <tt class="docutils literal"><span class="pre">{}</span></tt> 或 <tt class="docutils literal"><span class="pre">continue</span></tt>, 而不是一个简单的分号.</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Repeat test until it returns false.</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSomeNumber</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// Good - empty body.</span>
<span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// Good - continue indicates no logic.</span>
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>  <span class="c1">// Bad - looks like part of do/while loop.</span>
</pre></div>
</div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h4>8.8. 指针和引用表达式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">句点或箭头前后不要有空格. 指针/地址操作符 (<tt class="docutils literal"><span class="pre">*,</span> <span class="pre">&amp;</span></tt>) 之后不能有空格.</p>
</div>
<dl class="docutils">
<dt>下面是指针和引用表达式的正确使用范例:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
</dd>
<dt>注意:</dt>
<dd><ul class="first last simple">
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 <tt class="docutils literal"><span class="pre">*</span></tt> 或 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 后没有空格.</li>
</ul>
</dd>
<dt>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="c1">// These are fine, space preceding.</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">;</span>

<span class="c1">// These are fine, space following.</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>    <span class="c1">// but remember to do &quot;char* c, *d, *e, ...;&quot;!</span>
<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">;</span>
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// Bad - spaces on both sides of *</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">str</span><span class="p">;</span>  <span class="c1">// Bad - spaces on both sides of &amp;</span>
</pre></div>
</div>
</div>
</dd>
</dl>
<p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p>
</div>
<div class="section" id="id9">
<h4>8.9. 布尔表达式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果一个布尔表达式超过 <a class="reference internal" href="contents.html#line-length"><em>标准行宽</em></a>, 断行方式要统一一下.</p>
</div>
<dl class="docutils">
<dt>下例中, 逻辑与 (<tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>) 操作符总位于行尾:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">this_one_thing</span> <span class="o">&gt;</span> <span class="n">this_other_thing</span> <span class="o">&amp;&amp;</span>
    <span class="n">a_third_thing</span> <span class="o">==</span> <span class="n">a_fourth_thing</span> <span class="o">&amp;&amp;</span>
    <span class="n">yet_another</span> <span class="o">&amp;</span> <span class="n">last_one</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>注意, 上例的逻辑与 (<tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>) 操作符均位于行尾. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的.</p>
</div>
<div class="section" id="id10">
<h4>8.10. 函数返回值</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">return</span></tt> 表达式中不要用圆括号包围.</p>
</div>
<dl class="docutils">
<dt>函数返回时不要使用圆括号:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">return</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// not return(x);</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id11">
<h4>8.11. 变量及数组初始化</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用 <tt class="docutils literal"><span class="pre">=</span></tt> 或 <tt class="docutils literal"><span class="pre">()</span></tt> 均可.</p>
</div>
<dl class="docutils">
<dt>在二者中做出选择; 下面的方式都是正确的:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">x</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">string</span> <span class="nf">name</span><span class="p">(</span><span class="s">&quot;Some Name&quot;</span><span class="p">);</span>
<span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Some Name&quot;</span><span class="p">;</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id12">
<h4>8.12. 预处理指令</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">预处理指令不要缩进, 从行首开始.</p>
</div>
<dl class="docutils">
<dt>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="c1">// Good - directives at beginning of line</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lopsided_score</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if DISASTER_PENDING      </span><span class="c1">// Correct -- Starts at beginning of line</span>
    <span class="n">DropEverything</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="n">BackToNormal</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><pre>// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id13">
<h4>8.13. 类格式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">访问控制块的声明依次序是 <tt class="docutils literal"><span class="pre">public:</span></tt>, <tt class="docutils literal"><span class="pre">protected:</span></tt>, <tt class="docutils literal"><span class="pre">private:</span></tt>, 每次缩进 1 个空格.</p>
</div>
<dl class="docutils">
<dt>类声明 (对类注释不了解的话, 参考 <a class="reference internal" href="contents.html#class-comments"><em>类注释</em></a>) 的基本格式如下:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OtherClass</span> <span class="p">{</span>
 <span class="nl">public:</span>      <span class="c1">// Note the 1 space indent!</span>
  <span class="n">MyClass</span><span class="p">();</span>  <span class="c1">// Regular 2 space indent.</span>
  <span class="k">explicit</span> <span class="nf">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">);</span>
  <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">SomeFunction</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">SomeFunctionThatDoesNothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">set_some_var</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span> <span class="n">some_var_</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">some_var</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">some_var_</span><span class="p">;</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="kt">bool</span> <span class="n">SomeInternalFunction</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">some_var_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">some_other_var_</span><span class="p">;</span>
  <span class="n">DISALLOW_COPY_AND_ASSIGN</span><span class="p">(</span><span class="n">MyClass</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd>
<dt>注意事项:</dt>
<dd><ul class="first last simple">
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 <tt class="docutils literal"><span class="pre">public:</span></tt>, <tt class="docutils literal"><span class="pre">protected:</span></tt>, <tt class="docutils literal"><span class="pre">private:</span></tt> 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 <tt class="docutils literal"><span class="pre">public</span></tt>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li><tt class="docutils literal"><span class="pre">public</span></tt> 放在最前面, 然后是 <tt class="docutils literal"><span class="pre">protected</span></tt>, 最后是 <tt class="docutils literal"><span class="pre">private</span></tt>.</li>
<li>关于声明顺序的规则请参考 <a class="reference internal" href="contents.html#declaration-order"><em>声明顺序</em></a> 一节.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id14">
<h4>8.14. 初始化列表</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">构造函数初始化列表放在同一行或按四格缩进并排几行.</p>
</div>
<p>下面两种初始化列表方式都可以接受:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// When it all fits on one line:</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">some_other_var_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
</div></blockquote>
<p>或</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// When it requires multiple lines, indent 4 spaces, putting the colon on</span>
<span class="c1">// the first initializer line:</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span>             <span class="c1">// 4 space indent</span>
      <span class="n">some_other_var_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// lined up</span>
  <span class="p">...</span>
  <span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id15">
<h4>8.15. 名字空间格式化</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">名字空间内容不缩进.</p>
</div>
<dl class="docutils">
<dt><a class="reference internal" href="contents.html#namespaces"><em>名字空间</em></a> 不要增加额外的缩进层次, 例如:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="p">{</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// Correct.  No extra indentation within namespace.</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
</dd>
<dt>不要缩进名字空间:</dt>
<dd><div class="first last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="p">{</span>

  <span class="c1">// Wrong.  Indented when it should not be.</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id16">
<h4>8.16. 水平留白</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.</p>
</div>
<dl class="docutils">
<dt>常规:</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Open braces should always have a space before them.</span>
  <span class="p">...</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Semicolons usually have no space before them.</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>  <span class="c1">// Spaces inside braces for array initialization are</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>    <span class="c1">// optional.  If you use them, put them on both sides!</span>
<span class="c1">// Spaces around the colon in inheritance and initializer lists.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bar</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// For inline function implementations, put spaces between the braces</span>
  <span class="c1">// and the implementation itself.</span>
  <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">Bar</span><span class="p">(),</span> <span class="n">baz_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// No spaces inside empty braces.</span>
  <span class="kt">void</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span> <span class="n">baz_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// Spaces separating braces from implementation.</span>
  <span class="p">...</span>
</pre></div>
</div>
<p class="last">添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（确信没有其他人在处理). (yospaly 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
</dd>
<dt>循环和条件语句:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>          <span class="c1">// Space after the keyword in conditions and loops.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>          <span class="c1">// Spaces around else.</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">{}</span>   <span class="c1">// There is usually no space inside parentheses.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span>    <span class="c1">// Loops and conditions may have spaces inside</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">test</span> <span class="p">)</span> <span class="p">{</span>     <span class="c1">// parentheses, but this is rare.  Be consistent.</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// For loops always have a space after the</span>
  <span class="p">...</span>                   <span class="c1">// semicolon, and may have a space before the</span>
                        <span class="c1">// semicolon.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span>:         <span class="c1">// No space before colon in a switch case.</span>
    <span class="p">...</span>
  <span class="k">case</span> <span class="mi">2</span>: <span class="k">break</span><span class="p">;</span>  <span class="c1">// Use a space after a colon if there&#39;s code after it.</span>
</pre></div>
</div>
</dd>
<dt>操作符:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="c1">// Assignment operators always have spaces around</span>
                    <span class="c1">// them.</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>             <span class="c1">// No spaces separating unary operators and their</span>
<span class="o">++</span><span class="n">x</span><span class="p">;</span>                <span class="c1">// arguments.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">y</span><span class="p">)</span>
  <span class="p">...</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">;</span>  <span class="c1">// Binary operators usually have spaces around them,</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">;</span>      <span class="c1">// but it&#39;s okay to remove spaces around factors.</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span>    <span class="c1">// Parentheses should have no spaces inside them.</span>
</pre></div>
</div>
</dd>
<dt>模板和转换:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>           <span class="c1">// No spaces inside the angle</span>
<span class="n">y</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// brackets (&lt; and &gt;), before</span>
                            <span class="c1">// &lt;, or between &gt;( in a cast.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">x</span><span class="p">;</span>           <span class="c1">// Spaces between type and pointer are</span>
                            <span class="c1">// okay, but be consistent.</span>
<span class="n">set</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>       <span class="c1">// C++ requires a space in &gt; &gt;.</span>
<span class="n">set</span><span class="o">&lt;</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// You may optionally make use</span>
                            <span class="c1">// symmetric spacing in &lt; &lt;.</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id17">
<h4>8.17. 垂直留白</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">垂直留白越少越好.</p>
</div>
<p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p>
<p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 取决于你的判断. 但通常是垂直留白越少越好.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>函数首尾不要有空行</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">Function</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Unnecessary blank lines before and after</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>代码块首尾不要有空行</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Unnecessary blank line after</span>

<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Unnecessary blank line before</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">if-else</span></tt> 块之间空一行是可以接受的:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Some lines of code too small to move to another function,</span>
  <span class="c1">// followed by a blank line.</span>

<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// Another block of code</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple" start="0">
<li>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</li>
<li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li>
<li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</li>
<li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li>
<li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</li>
<li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</li>
<li><tt class="docutils literal"><span class="pre">.</span></tt>/<tt class="docutils literal"><span class="pre">-&gt;</span></tt> 操作符前后不留空格, <tt class="docutils literal"><span class="pre">*</span></tt>/<tt class="docutils literal"><span class="pre">&amp;</span></tt> 不要前后都留, 一个就可, 靠左靠右依各人喜好;</li>
<li>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</li>
<li>初始化用 <tt class="docutils literal"><span class="pre">=</span></tt> 还是 <tt class="docutils literal"><span class="pre">()</span></tt> 依个人喜好, 统一就好;</li>
<li><tt class="docutils literal"><span class="pre">return</span></tt> 不要加 <tt class="docutils literal"><span class="pre">()</span></tt>;</li>
<li>水平/垂直留白不要滥用, 怎么易读怎么来.</li>
<li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (<tt class="docutils literal"><span class="pre">.cc</span></tt> 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/exceptions"></span><div class="section" id="id1">
<h3>9. 规则特例</h3>
<p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<div class="section" id="id2">
<h4>9.1. 现有不合规范的代码</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对于现有不符合既定编程风格的代码可以网开一面.</p>
</div>
<p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心可以与代码原作者或现在的负责人员商讨, 记住, <em>一致性</em> 包括原有的一致性.</p>
</div>
<div class="section" id="windows">
<span id="windows-code"></span><h4>9.2. Windows 代码</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p>
</div>
<p>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
<blockquote>
<div><ul class="simple">
<li>不要使用匈牙利命名法 (比如把整型变量命名成 <tt class="docutils literal"><span class="pre">iNum</span></tt>). 使用 Google 命名约定, 包括对源文件使用 <tt class="docutils literal"><span class="pre">.cc</span></tt> 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <tt class="docutils literal"><span class="pre">DWORD</span></tt>, <tt class="docutils literal"><span class="pre">HANDLE</span></tt> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 但还是尽量使用原有的 C++ 类型, 例如, 使用 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">TCHAR</span> <span class="pre">*</span></tt> 而不是 <tt class="docutils literal"><span class="pre">LPCTSTR</span></tt>.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有 warnings 当作 errors 处理.</li>
<li>不要使用 <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">once</span></tt>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (yospaly 注: 如 <tt class="docutils literal"><span class="pre">#ifndef</span> <span class="pre">SRC_DIR_BAR_H_</span></tt>, 参考 <a class="reference internal" href="contents.html#define-guard"><em>#define 保护</em></a> 一节).</li>
<li>除非万不得已, 不要使用任何非标准的扩展, 如 <tt class="docutils literal"><span class="pre">#pragma</span></tt> 和 <tt class="docutils literal"><span class="pre">__declspec</span></tt>. 允许使用 <tt class="docutils literal"><span class="pre">__declspec(dllimport)</span></tt> 和 <tt class="docutils literal"><span class="pre">__declspec(dllexport)</span></tt>; 但你必须通过宏来使用, 比如 <tt class="docutils literal"><span class="pre">DLLIMPORT</span></tt> 和 <tt class="docutils literal"><span class="pre">DLLEXPORT</span></tt>, 这样其他人在分享使用这些代码时很容易就去掉这些扩展.</li>
</ul>
</div></blockquote>
<p>在 Windows 上, 只有很少的一些情况下, 我们可以偶尔违反规则:</p>
<blockquote>
<div><ul class="simple">
<li>通常我们 <a class="reference internal" href="contents.html#multiple-inheritance"><em>禁止使用多重继承</em></a>, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <tt class="docutils literal"><span class="pre">_ATL_NO_EXCEPTIONS</span></tt> 以禁用异常. 你要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 启用编译器异常也可以. (注意这只是为了编译 STL, 自己代码里仍然不要含异常处理.)</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <tt class="docutils literal"><span class="pre">StdAfx.h</span></tt> 或 <tt class="docutils literal"><span class="pre">precompile.h</span></tt> 的文件. 为了使代码方便与其他项目共享, 避免显式包含此文件 (<tt class="docutils literal"><span class="pre">precompile.cc</span></tt>), 使用 <tt class="docutils literal"><span class="pre">/FI</span></tt> 编译器选项以自动包含.</li>
<li>资源头文件通常命名为 <tt class="docutils literal"><span class="pre">resource.h</span></tt>, 且只包含宏的, 不需要遵守本风格指南.</li>
</ul>
</div></blockquote>
</div>
</div>
<span id="document-google-cpp-styleguide/end"></span><div class="section" id="id1">
<h3>10. 结束语</h3>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">运用常识和判断力, 并 <em>保持一致</em>.</p>
</div>
<p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 <tt class="docutils literal"><span class="pre">if</span></tt> 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 你同样要这么做.</p>
<p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示了全局的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也影响阅读, 所以要尽量避免.</p>
<p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p>
<div class="highlight-python"><pre>Revision 3.133

Benjy Weinberger
Craig Silverstein
Gregory Eitzmann
Mark Mentovai
Tashana Landray</pre>
</div>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/contents"></span><div class="section" id="objective-c">
<span id="objc-contents"></span><h2>Objective-C 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-objc-styleguide/index"></span><div class="section" id="google-objective-c-style-guide">
<h3>Google Objective-C Style Guide 中文版</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">2.36</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Mike Pinkerton</div>
<div class="line">Greg Miller</div>
<div class="line">Dave MacLachlan</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://ke.indiebros.com/">ewangke</a></div>
<div class="line"><a class="reference external" href="http://yangyubo.com">brantyoung</a></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="http://google-styleguide.googlecode.com">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="id1">
<h4>译者的话</h4>
<div class="section" id="ewanke">
<h5>ewanke</h5>
<p>一直想翻译这个 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml">style guide</a> ，终于在周末花了7个小时的时间用vim敲出了HTML。很多术语的翻译很难，平时看的中文技术类书籍有限，对很多术语的中文译法不是很清楚，难免有不恰当之处，请读者指出并帮我改进：王轲 ”ewangke at gmail.com” 2011.03.27</p>
</div>
<div class="section" id="id2">
<h5>brantyoung</h5>
<p>对 Objective-C 的了解有限，凭着感觉和 C/C++ 方面的理解：</p>
<ul class="simple">
<li>把指南更新到 2.36 版本</li>
<li>调整了一些术语和句子</li>
</ul>
</div>
</div>
<div class="section" id="id3">
<h4>背景介绍</h4>
<p>Objective-C 是 C 语言的扩展，增加了动态类型和面对对象的特性。它被设计成具有易读易用的，支持复杂的面向对象设计的编程语言。它是 Mac OS X 以及 iPhone 的主要开发语言。</p>
<p>Cocoa 是 Mac OS X 上主要的应用程序框架之一。它由一组 Objective-C 类组成，为快速开发出功能齐全的 Mac OS X 应用程序提供支持。</p>
<p>苹果公司已经有一份非常全面的 Objective-C 编码指南。Google 为 C++ 也写了一份类似的编码指南。而这份 Objective-C 指南则是苹果和 Google 常规建议的最佳结合。因此，在阅读本指南之前，请确定你已经阅读过：</p>
<ul class="simple">
<li><a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/index.html">Apple’s Cocoa Coding Guidelines</a></li>
<li><a class="reference external" href="http://codinn.com/projects/google-cpp-styleguide/">Google’s Open Source C++ Style Guide</a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">所有在 Google 的 C++ 风格指南中所禁止的事情，如未明确说明，也同样不能在Objective-C++ 中使用。</p>
</div>
<p>本文档的目的在于为所有的 Mac OS X 的代码提供编码指南及实践。许多准则是在实际的项目和小组中经过长期的演化、验证的。Google 开发的开源项目遵从本指南的要求。</p>
<p>Google 已经发布了遵守本指南开源代码，它们属于 <a class="reference external" href="http://code.google.com/p/google-toolbox-for-mac/">Google Toolbox for Mac project</a> 项目（本文以缩写 GTM 指代）。GTM 代码库中的代码通常为了可以在不同项目中复用。</p>
<p>注意，本指南不是 Objective-C 教程。我们假定读者对 Objective-C 非常熟悉。如果你刚刚接触 Objective-C 或者需要温习，请阅读 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/index.html">The Objective-C Programming Language</a> 。</p>
</div>
<div class="section" id="id4">
<h4>例子</h4>
<p>都说一个例子顶上一千句话，我们就从一个例子开始，来感受一下编码的风格、留白以及命名等等。</p>
<p>一个头文件的例子，展示了在 <tt class="docutils literal"><span class="pre">&#64;interface</span></tt> 声明中如何进行正确的注释以及留白。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">//  Foo.h</span>
<span class="c1">//  AwesomeProject</span>
<span class="c1">//</span>
<span class="c1">//  Created by Greg Miller on 6/13/08.</span>
<span class="c1">//  Copyright 2008 Google, Inc. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="c1">// A sample class demonstrating good Objective-C style. All interfaces,</span>
<span class="c1">// categories, and protocols (read: all top-level declarations in a header)</span>
<span class="c1">// MUST be commented. Comments must also be adjacent to the object they&#39;re</span>
<span class="c1">// documenting.</span>
<span class="c1">//</span>
<span class="c1">// (no blank line between this comment and the interface)</span>
<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">bar_</span><span class="p">;</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">bam_</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns an autoreleased instance of Foo. See -initWithBar: for details</span>
<span class="c1">// about |bar|.</span>
<span class="o">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">fooWithBar</span><span class="o">:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">bar</span><span class="p">;</span>

<span class="c1">// Designated initializer. |bar| is a thing that represents a thing that</span>
<span class="c1">// does a thing.</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBar:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Gets and sets |bar_|.</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">bar</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBar:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Does some work with |blah| and returns YES if the work was completed</span>
<span class="c1">// successfully, and NO otherwise.</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doWorkWithBlah:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">blah</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>
</div>
<p>一个源文件的例子，展示了 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 部分如何进行正确的注释、留白。同时也包括了基于引用实现的一些重要方法，如 <tt class="docutils literal"><span class="pre">getters</span></tt> 、 <tt class="docutils literal"><span class="pre">setters</span></tt> 、 <tt class="docutils literal"><span class="pre">init</span></tt> 以及 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">//</span>
<span class="c1">//  Foo.m</span>
<span class="c1">//  AwesomeProject</span>
<span class="c1">//</span>
<span class="c1">//  Created by Greg Miller on 6/13/08.</span>
<span class="c1">//  Copyright 2008 Google, Inc. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#import &quot;Foo.h&quot;</span>


<span class="k">@implementation</span> <span class="nc">Foo</span>

<span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">fooWithBar:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithBar</span><span class="o">:</span><span class="n">bar</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Must always override super&#39;s designated initializer.</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">initWithBar</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBar:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">bar_</span> <span class="o">=</span> <span class="p">[</span><span class="n">bar</span> <span class="n">copy</span><span class="p">];</span>
    <span class="n">bam_</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithFormat</span><span class="o">:</span><span class="s">@&quot;hi %d&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="n">release</span><span class="p">];</span>
  <span class="p">[</span><span class="n">bam_</span> <span class="n">release</span><span class="p">];</span>
  <span class="p">[</span><span class="n">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">bar</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bar_</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBar:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="n">autorelease</span><span class="p">];</span>
  <span class="n">bar_</span> <span class="o">=</span> <span class="p">[</span><span class="n">bar</span> <span class="n">copy</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doWorkWithBlah:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">blah</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></div>
</div>
<p>不要求在 <tt class="docutils literal"><span class="pre">&#64;interface``、``&#64;implementation</span></tt> 和 <tt class="docutils literal"><span class="pre">&#64;end</span></tt> 前后空行。如果你在 <tt class="docutils literal"><span class="pre">&#64;interface</span></tt> 声明了实例变量，则须在关括号 <tt class="docutils literal"><span class="pre">}</span></tt> 之后空一行。</p>
<p>除非接口和实现非常短，比如少量的私有方法或桥接类，空行方有助于可读性。</p>
</div>
</div>
<span id="document-google-objc-styleguide/spacing"></span><div class="section" id="id1">
<h3>留白和格式</h3>
<div class="section" id="vs">
<h4>空格 vs. 制表符</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用空格，且一次缩进两个空格。</p>
</div>
<p>我们使用空格缩进。不要在代码中使用制表符。你应该将编辑器设置成自动将制表符替换成空格。</p>
</div>
<div class="section" id="id2">
<h4>行宽</h4>
<p>尽量让你的代码保持在 80 列之内。</p>
<p>我们深知 Objective-C 是一门繁冗的语言，在某些情况下略超 80 列可能有助于提高可读性，但这也只能是特例而已，不能成为开脱。</p>
<p>如果阅读代码的人认为把把某行行宽保持在 80 列仍然有不失可读性，你应该按他们说的去做。</p>
<p>我们意识到这条规则是有争议的，但很多已经存在的代码坚持了本规则，我们觉得保证一致性更重要。</p>
<p>通过设置 <a href="#id3"><span class="problematic" id="id4">*</span></a>Xcode &gt; Preferences &gt; Text Editing &gt; Show page guide*，来使越界更容易被发现。</p>
</div>
<div class="section" id="id5">
<h4>方法声明和定义</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<ul class="last simple">
<li>/ + 和返回类型之间须使用一个空格，参数列表中只有参数之间可以有空格。</li>
</ul>
</div>
<p>方法应该像这样：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomethingWithString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">theString</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>星号前的空格是可选的。当写新的代码时，要与先前代码保持一致。</p>
<p>如果一行有非常多的参数，更好的方式是将每个参数单独拆成一行。如果使用多行，将每个参数前的冒号对齐。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomethingWith:</span><span class="p">(</span><span class="n">GTMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">theFoo</span>
                   <span class="nl">rect:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">theRect</span>
               <span class="nl">interval:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">theInterval</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当第一个关键字比其它的短时，保证下一行至少有 4 个空格的缩进。这样可以使关键字垂直对齐，而不是使用冒号对齐：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">short:</span><span class="p">(</span><span class="n">GTMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">theFoo</span>
    <span class="nl">longKeyword:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">theRect</span>
    <span class="nl">evenLongerKeyword:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">theInterval</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>方法调用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">方法调用应尽量保持与方法声明的格式一致。当格式的风格有多种选择时，新的代码要与已有代码保持一致。</p>
</div>
<p>调用时所有参数应该在同一行：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="p">[</span><span class="n">myObject</span> <span class="n">doFooWith</span><span class="o">:</span><span class="n">arg1</span> <span class="n">name</span><span class="o">:</span><span class="n">arg2</span> <span class="n">error</span><span class="o">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>或者每行一个参数，以冒号对齐：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="p">[</span><span class="n">myObject</span> <span class="n">doFooWith</span><span class="o">:</span><span class="n">arg1</span>
               <span class="nl">name:</span><span class="n">arg2</span>
              <span class="nl">error:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>不要使用下面的缩进风格：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="p">[</span><span class="n">myObject</span> <span class="n">doFooWith</span><span class="o">:</span><span class="n">arg1</span> <span class="n">name</span><span class="o">:</span><span class="n">arg2</span>  <span class="c1">// some lines with &gt;1 arg</span>
              <span class="nl">error:</span><span class="n">arg3</span><span class="p">];</span>

<span class="p">[</span><span class="n">myObject</span> <span class="n">doFooWith</span><span class="o">:</span><span class="n">arg1</span>
               <span class="nl">name:</span><span class="n">arg2</span> <span class="n">error</span><span class="o">:</span><span class="n">arg3</span><span class="p">];</span>

<span class="p">[</span><span class="n">myObject</span> <span class="n">doFooWith</span><span class="o">:</span><span class="n">arg1</span>
          <span class="nl">name:</span><span class="n">arg2</span>  <span class="c1">// aligning keywords instead of colons</span>
          <span class="nl">error:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>方法定义与方法声明一样，当关键字的长度不足以以冒号对齐时，下一行都要以四个空格进行缩进。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="p">[</span><span class="n">myObj</span> <span class="kt">short</span><span class="o">:</span><span class="n">arg1</span>
    <span class="nl">longKeyword:</span><span class="n">arg2</span>
    <span class="nl">evenLongerKeyword:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="public-private">
<h4><tt class="docutils literal"><span class="pre">&#64;public</span></tt> 和 <tt class="docutils literal"><span class="pre">&#64;private</span></tt></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">&#64;public</span></tt> 和 <tt class="docutils literal"><span class="pre">&#64;private</span></tt> 访问修饰符应该以一个空格缩进。</p>
</div>
<p>与 C++ 中的 <tt class="docutils literal"><span class="pre">public,</span> <span class="pre">private</span></tt> 以及 <tt class="docutils literal"><span class="pre">protected</span></tt> 非常相似。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@interface</span> <span class="nc">MyClass</span> : <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@public</span>
  <span class="p">...</span>
 <span class="k">@private</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个 <tt class="docutils literal"><span class="pre">&#64;</span></tt> 标签应该有独立的一行，在 <tt class="docutils literal"><span class="pre">&#64;</span></tt> 与 <tt class="docutils literal"><span class="pre">{}</span></tt> 之间需要有一个空格， <tt class="docutils literal"><span class="pre">&#64;catch</span></tt> 与被捕捉到的异常对象的声明之间也要有一个空格。</p>
</div>
<p>如果你决定使用 Objective-C 的异常，那么就按下面的格式。不过你最好先看看 <a class="reference internal" href="contents.html#avoid-throwing-exceptions"><em>避免抛出异常</em></a> 了解下为什么不要使用异常。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@try</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">@catch</span> <span class="p">(</span><span class="n">NSException</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@finally</span> <span class="p">{</span>
  <span class="n">baz</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>协议名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类型标识符和尖括号内的协议名之间，不能有任何空格。</p>
</div>
<p>这条规则适用于类声明、实例变量以及方法声明。例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@interface</span> <span class="nc">MyProtocoledClass</span> : <span class="nc">NSObject</span><span class="o">&lt;</span><span class="n">NSWindowDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span> <span class="n">delegate_</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setDelegate</span><span class="o">:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="n">aDelegate</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>块（闭包）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">块（block）适合用在 target/selector 模式下创建回调方法时，因为它使代码更易读。块中的代码应该缩进 4 个空格。</p>
</div>
<p>取决于块的长度，下列都是合理的风格准则：</p>
<ul class="simple">
<li>如果一行可以写完块，则没必要换行。</li>
<li>如果不得不换行，关括号应与块声明的第一个字符对齐。</li>
<li>块内的代码须按 4 空格缩进。</li>
<li>如果块太长，比如超过 20 行，建议把它定义成一个局部变量，然后再使用该变量。</li>
<li>如果块不带参数，``^{`` 之间无须空格。如果带有参数，``^(`` 之间无须空格，但 <tt class="docutils literal"><span class="pre">)</span> <span class="pre">{</span></tt> 之间须有一个空格。</li>
<li>块内允许按两个空格缩进，但前提是和项目的其它代码保持一致的缩进风格。</li>
</ul>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// The entire block fits on one line.</span>
<span class="p">[</span><span class="n">operation</span> <span class="n">setCompletionBlock</span><span class="o">:^</span><span class="p">{</span> <span class="p">[</span><span class="n">self</span> <span class="n">onOperationDone</span><span class="p">];</span> <span class="p">}];</span>

<span class="c1">// The block can be put on a new line, indented four spaces, with the</span>
<span class="c1">// closing brace aligned with the first character of the line on which</span>
<span class="c1">// block was declared.</span>
<span class="p">[</span><span class="n">operation</span> <span class="n">setCompletionBlock</span><span class="o">:^</span><span class="p">{</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="n">newDataAvailable</span><span class="p">];</span>
<span class="p">}];</span>

<span class="c1">// Using a block with a C API follows the same alignment and spacing</span>
<span class="c1">// rules as with Objective-C.</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">fileIOQueue_</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">NSString</span><span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">sessionFilePath</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// An example where the parameter wraps and the block declaration fits</span>
<span class="c1">// on the same line. Note the spacing of |^(SessionWindow *window) {|</span>
<span class="c1">// compared to |^{| above.</span>
<span class="p">[[</span><span class="n">SessionService</span> <span class="n">sharedService</span><span class="p">]</span>
    <span class="nl">loadWindowWithCompletionBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">SessionWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
          <span class="p">[</span><span class="n">self</span> <span class="n">windowDidLoad</span><span class="o">:</span><span class="n">window</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="p">[</span><span class="n">self</span> <span class="n">errorLoadingWindow</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}];</span>

<span class="c1">// An example where the parameter wraps and the block declaration does</span>
<span class="c1">// not fit on the same line as the name.</span>
<span class="p">[[</span><span class="n">SessionService</span> <span class="n">sharedService</span><span class="p">]</span>
    <span class="nl">loadWindowWithCompletionBlock:</span>
        <span class="o">^</span><span class="p">(</span><span class="n">SessionWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
              <span class="p">[</span><span class="n">self</span> <span class="n">windowDidLoad</span><span class="o">:</span><span class="n">window</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="p">[</span><span class="n">self</span> <span class="n">errorLoadingWindow</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}];</span>

<span class="c1">// Large blocks can be declared out-of-line.</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">largeBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">operationQueue_</span> <span class="n">addOperationWithBlock</span><span class="o">:</span><span class="n">largeBlock</span><span class="p">];</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/naming"></span><div class="section" id="id1">
<h3>命名</h3>
<p>对于易维护的代码而言，命名规则非常重要。Objective-C 的方法名往往十分长，但代码块读起来就像散文一样，不需要太多的代码注释。</p>
<p>当编写纯粹的 Objective-C 代码时，我们基本遵守标准的 <a href="#id2"><span class="problematic" id="id3">`</span></a>Objective-C naming rules &lt;<a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html</a>&gt;`_，这些命名规则可能与 C++ 风格指南中的大相径庭。例如，Google 的 C++ 风格指南中推荐使用下划线分隔的单词作为变量名，而(苹果的)风格指南则使用驼峰命名法，这在 Objective-C 社区中非常普遍。</p>
<p>任何的类、类别、方法以及变量的名字中都使用全大写的 <a href="#id4"><span class="problematic" id="id5">`</span></a>首字母缩写 &lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Initialism">http://en.wikipedia.org/wiki/Initialism</a>&gt;`_。这遵守了苹果的标准命名方式，如 URL、TIFF 以及 EXIF。</p>
<p>当编写 Objective-C++ 代码时，事情就不这么简单了。许多项目需要实现跨平台的 C++ API，并混合一些 Objective-C、Cocoa 代码，或者直接以 C++ 为后端，前端用本地 Cocoa 代码。这就导致了两种命名方式直接不统一。</p>
<p>我们的解决方案是：编码风格取决于方法/函数以哪种语言实现。如果在一个 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 语句中，就使用 Objective-C 的风格。如果实现一个 C++ 的类，就使用 C++ 的风格。这样避免了一个函数里面实例变量和局部变量命名规则混乱，严重影响可读性。</p>
<div class="section" id="id6">
<h4>文件名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">文件名须反映出其实现了什么类 &#8211; 包括大小写。遵循你所参与项目的约定。</p>
</div>
<p>文件的扩展名应该如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">.h</span></tt></td>
<td>C/C++/Objective-C 的头文件</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">.m</span></tt></td>
<td>Ojbective-C 实现文件</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">.mm</span></tt></td>
<td>Ojbective-C++ 的实现文件</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">.cc</span></tt></td>
<td>纯 C++ 的实现文件</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">.c</span></tt></td>
<td>纯 C 的实现文件</td>
</tr>
</tbody>
</table>
<p>类别的文件名应该包含被扩展的类名，如：``GTMNSString+Utils.h`` 或``GTMNSTextView+Autocomplete.h``。</p>
</div>
<div class="section" id="objective-c">
<h4>Objective-C++</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">源代码文件内，Ojbective-C++ 代码遵循你正在实现的函数/方法的风格。</p>
</div>
<p>为了最小化 Cocoa/Objective-C 与 C++ 之间命名风格的冲突，根据待实现的函数/方法选择编码风格。实现 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 语句块时，使用 Objective-C 的命名规则；如果实现一个 C++ 的类，就使用 C++ 命名规则。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// file: cross_platform_header.h</span>

<span class="n">class</span> <span class="n">CrossPlatformAPI</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="p">...</span>
  <span class="kt">int</span> <span class="n">DoSomethingPlatformSpecific</span><span class="p">();</span>  <span class="c1">// impl on each platform</span>
 <span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">an_instance_var_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// file: mac_implementation.mm</span>
<span class="cp">#include &quot;cross_platform_header.h&quot;</span>

<span class="c1">// A typical Objective-C class, using Objective-C naming.</span>
<span class="k">@interface</span> <span class="nc">MyDelegate</span> : <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">int</span> <span class="n">instanceVar_</span><span class="p">;</span>
  <span class="n">CrossPlatformAPI</span><span class="o">*</span> <span class="n">backEndObject_</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">respondToSomething</span><span class="o">:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">something</span><span class="p">;</span>
<span class="k">@end</span>
<span class="k">@implementation</span> <span class="nc">MyDelegate</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">respondToSomething:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">something</span> <span class="p">{</span>
  <span class="c1">// bridge from Cocoa through our C++ backend</span>
  <span class="n">instanceVar_</span> <span class="o">=</span> <span class="n">backEndObject</span><span class="o">-&gt;</span><span class="n">DoSomethingPlatformSpecific</span><span class="p">();</span>
  <span class="n">NSString</span><span class="o">*</span> <span class="n">tempString</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="n">stringWithInt</span><span class="o">:</span><span class="n">instanceVar_</span><span class="p">];</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">tempString</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// The platform-specific implementation of the C++ class, using</span>
<span class="c1">// C++ naming.</span>
<span class="kt">int</span> <span class="n">CrossPlatformAPI</span><span class="o">::</span><span class="n">DoSomethingPlatformSpecific</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">NSString</span><span class="o">*</span> <span class="n">temp_string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="n">stringWithInt</span><span class="o">:</span><span class="n">an_instance_var_</span><span class="p">];</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">temp_string</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">temp_string</span> <span class="n">intValue</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>类名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词。</p>
</div>
<p><em>应用层</em> 的代码，应该尽量避免不必要的前缀。为每个类都添加相同的前缀无助于可读性。当编写的代码期望在不同应用程序间复用时，应使用前缀（如：``GTMSendMessage``）。</p>
</div>
<div class="section" id="id8">
<h4>类别名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类别名应该有两三个字母的前缀以表示类别是项目的一部分或者该类别是通用的。类别名应该包含它所扩展的类的名字。</p>
</div>
<p>比如我们要基于 <tt class="docutils literal"><span class="pre">NSString</span></tt> 创建一个用于解析的类别，我们将把类别放在一个名为 <tt class="docutils literal"><span class="pre">GTMNSString+Parsing.h</span></tt> 的文件中。类别本身命名为 <tt class="docutils literal"><span class="pre">GTMStringParsingAdditions</span></tt> （是的，我们知道类别名和文件名不一样，但是这个文件中可能存在多个不同的与解析有关类别）。类别中的方法应该以 <tt class="docutils literal"><span class="pre">gtm_myCategoryMethodOnAString:</span></tt> 为前缀以避免命名冲突，因为 Objective-C 只有一个名字空间。如果代码不会分享出去，也不会运行在不同的地址空间中，方法名字就不那么重要了。</p>
<p>类名与包含类别名的括号之间，应该以一个空格分隔。</p>
</div>
<div class="section" id="id9">
<h4>Objective-C 方法名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">方法名应该以小写字母开头，并混合驼峰格式。每个具名参数也应该以小写字母开头。</p>
</div>
<p>方法名应尽量读起来就像句子，这表示你应该选择与方法名连在一起读起来通顺的参数名。（例如，``convertPoint:fromRect:`` 或 <a href="#id10"><span class="problematic" id="id11">``</span></a>replaceCharactersInRange:withString:<a href="#id12"><span class="problematic" id="id13">``</span></a>）。详情参见 <a href="#id14"><span class="problematic" id="id15">`</span></a>Apple’s Guide to Naming Methods &lt;<a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html">http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html</a>&gt;`_。</p>
<p>访问器方法应该与他们 <tt class="docutils literal"><span class="pre">要获取的</span></tt> 成员变量的名字一样，但不应该以get作为前缀。例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">getDelegate</span><span class="p">;</span>  <span class="c1">// AVOID</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">delegate</span><span class="p">;</span>     <span class="c1">// GOOD</span>
</pre></div>
</div>
<p>这仅限于 Objective-C 的方法名。C++ 的方法与函数的命名规则应该遵从 C++ 风格指南中的规则。</p>
</div>
<div class="section" id="id16">
<h4>变量名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">变量名应该以小写字母开头，并使用驼峰格式。类的成员变量应该以下划线作为后缀。例如：``myLocalVariable``、``myInstanceVariable_``。如果不能使用 Objective-C 2.0 的 <a href="#id17"><span class="problematic" id="id18">``</span></a>&#64;property``，使用 KVO/KVC 绑定的成员变量可以以一个下划线作为前缀。</p>
</div>
<div class="section" id="id19">
<h5>普通变量名</h5>
<p>对于静态的属性（``int`` 或指针），不要使用匈牙利命名法。尽量为变量起一个描述性的名字。不要担心浪费列宽，因为让新的代码阅读者立即理解你的代码更重要。例如：</p>
<ul>
<li><p class="first">错误的命名：</p>
<blockquote>
<div><div class="highlight-objc"><div class="highlight"><pre><span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nerr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nCompConns</span><span class="p">;</span>
<span class="n">tix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">someObject</span> <span class="n">object</span><span class="p">];</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span> <span class="n">port</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">正确的命名：</p>
<blockquote>
<div><div class="highlight-objc"><div class="highlight"><pre><span class="kt">int</span> <span class="n">numErrors</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">numCompletedConnections</span><span class="p">;</span>
<span class="n">tickets</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="n">userInfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">someObject</span> <span class="n">object</span><span class="p">];</span>
<span class="n">port</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span> <span class="n">port</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id20">
<h5>实例变量</h5>
<p>实例变量应该混合大小写，并以下划线作为后缀，如 <tt class="docutils literal"><span class="pre">usernameTextField_``。然而，如果不能使用</span> <span class="pre">Objective-C</span> <span class="pre">2.0（操作系统版本的限制），并且使用了</span> <span class="pre">KVO/KVC</span> <span class="pre">绑定成员变量时，我们允许例外（译者注：</span> <span class="pre">``KVO=Key</span> <span class="pre">Value</span> <span class="pre">Observing，KVC=Key</span> <span class="pre">Value</span> <span class="pre">Coding``）。这种情况下，可以以一个下划线作为成员变量名字的前缀，这是苹果所接受的键/值命名惯例。如果可以使用</span> <span class="pre">Objective-C</span> <span class="pre">2.0，``&#64;property</span></tt> 以及 <tt class="docutils literal"><span class="pre">&#64;synthesize</span></tt> 提供了遵从这一命名规则的解决方案。</p>
</div>
<div class="section" id="id21">
<h5>常量</h5>
<p>常量名（如宏定义、枚举、静态局部变量等）应该以小写字母 <tt class="docutils literal"><span class="pre">k</span></tt> 开头，使用驼峰格式分隔单词，如：``kInvalidHandle，kWritePerm``。</p>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/comments"></span><div class="section" id="id1">
<h3>注释</h3>
<p>虽然写起来很痛苦，但注释是保证代码可读性的关键。下面的规则给出了你应该什么时候、在哪进行注释。记住：尽管注释很重要，但最好的代码应该自成文档。与其给类型及变量起一个晦涩难懂的名字，再为它写注释，不如直接起一个有意义的名字。</p>
<p>当你写注释的时候，记得你是在给你的听众写，即下一个需要阅读你所写代码的贡献者。大方一点，下一个读代码的人可能就是你！</p>
<p>记住所有 C++ 风格指南里的规则在这里也同样适用，不同的之处后续会逐步指出。</p>
<div class="section" id="id2">
<h4>文件注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个文件的开头以文件内容的简要描述起始，紧接着是作者，最后是版权声明和/或许可证样板。</p>
</div>
<div class="section" id="id3">
<h5>版权信息及作者</h5>
<p>每个文件应该按顺序包括如下项：</p>
<ul class="simple">
<li>文件内容的简要描述</li>
<li>代码作者</li>
<li>版权信息声明（如：``Copyright 2008 Google Inc.``）</li>
<li>必要的话，加上许可证样板。为项目选择一个合适的授权样板（例如，``Apache 2.0, BSD, LGPL, GPL``）。</li>
</ul>
<p>如果你对其他人的原始代码作出重大的修改，请把你自己的名字添加到作者里面。当另外一个代码贡献者对文件有问题时，他需要知道怎么联系你，这十分有用。</p>
</div>
</div>
<div class="section" id="id4">
<h4>声明部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个接口、类别以及协议应辅以注释，以描述它的目的及与整个项目的关系。</p>
</div>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// A delegate for NSApplication to handle notifications about app</span>
<span class="c1">// launch and shutdown. Owned by the main app controller.</span>
<span class="k">@interface</span> <span class="nc">MyAppDelegate</span> : <span class="nc">NSObject</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>如果你已经在文件头部详细描述了接口，可以直接说明 “完整的描述请参见文件头部”，但是一定要有这部分注释。</p>
<p>另外，公共接口的每个方法，都应该有注释来解释它的作用、参数、返回值以及其它影响。</p>
<p>为类的线程安全性作注释，如果有的话。如果类的实例可以被多个线程访问，记得注释多线程条件下的使用规则。</p>
</div>
<div class="section" id="id5">
<h4>实现部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <tt class="docutils literal"><span class="pre">|</span></tt> 来引用注释中的变量名及符号名而不是使用引号。</p>
</div>
<p>这会避免二义性，尤其是当符号是一个常用词汇，这使用语句读起来很糟糕。例如，对于符号 <tt class="docutils literal"><span class="pre">count</span></tt> ：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// Sometimes we need |count| to be less than zero.</span>
</pre></div>
</div>
<p>或者当引用已经包含引号的符号：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>对象所有权</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当与 Objective-C 最常规的作法不同时，尽量使指针的所有权模型尽量明确。</p>
</div>
<p>继承自 <tt class="docutils literal"><span class="pre">NSObject</span></tt> 的对象的实例变量指针，通常被假定是强引用关系（retained），某些情况下也可以注释为弱引用（weak）或使用 <tt class="docutils literal"><span class="pre">__weak</span></tt> 生命周期限定符。同样，声明的属性如果没有被类 <tt class="docutils literal"><span class="pre">retained``，必须指定是弱引用或赋予</span> <span class="pre">``&#64;property</span></tt> 属性。然而，Mac 软件中标记上 <tt class="docutils literal"><span class="pre">IBOutlets</span></tt> 的实例变量，被认为是不会被类 <tt class="docutils literal"><span class="pre">retained</span></tt> 的。</p>
<p>当实例变量指向 <tt class="docutils literal"><span class="pre">CoreFoundation``、C++</span> <span class="pre">或者其它非</span> <span class="pre">Objective-C</span> <span class="pre">对象时，不论指针是否会被</span> <span class="pre">``retained``，都需要使用</span> <span class="pre">``__strong</span></tt> 和 <tt class="docutils literal"><span class="pre">__weak</span></tt> 类型修饰符明确指明。``CoreFoundation`` 和其它非 Objective-C 对象指针需要显式的内存管理，即便使用了自动引用计数或垃圾回收机制。当不允许使用 <tt class="docutils literal"><span class="pre">__weak</span></tt> 类型修饰符（比如，使用 clang 编译时的 C++ 成员变量），应使用注释替代说明。</p>
<p>注意：Objective-C 对象中的 C++ 对象的自动封装，缺省是不允许的，参见 <a class="reference external" href="http://chanson.livejournal.com/154253.html">这里</a> 的说明。</p>
<p>强引用及弱引用声明的例子：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@interface</span> <span class="nc">MyDelegate</span> : <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">IBOutlet</span> <span class="n">NSButton</span> <span class="o">*</span><span class="n">okButton_</span><span class="p">;</span>  <span class="c1">// normal NSControl; implicitly weak on Mac only</span>

  <span class="n">AnObjcObject</span><span class="o">*</span> <span class="n">doohickey_</span><span class="p">;</span>  <span class="c1">// my doohickey</span>
  <span class="n">__weak</span> <span class="n">MyObjcParent</span> <span class="o">*</span><span class="n">parent_</span><span class="p">;</span>  <span class="c1">// so we can send msgs back (owns me)</span>

  <span class="c1">// non-NSObject pointers...</span>
  <span class="n">__strong</span> <span class="n">CWackyCPPClass</span> <span class="o">*</span><span class="n">wacky_</span><span class="p">;</span>  <span class="c1">// some cross-platform object</span>
  <span class="n">__strong</span> <span class="n">CFDictionaryRef</span> <span class="o">*</span><span class="n">dict_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">doohickey</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>（译注：强引用 - 对象被类 <a href="#id8"><span class="problematic" id="id9">``</span></a>retained``。弱引用 - 对象没有被类 <a href="#id10"><span class="problematic" id="id11">``</span></a>retained``，如委托）</p>
</div>
</div>
<span id="document-google-objc-styleguide/features"></span><div class="section" id="cocoa-objective-c">
<h3>Cocoa 和 Objective-C 特性</h3>
<div class="section" id="private">
<h4>成员变量应该是 <tt class="docutils literal"><span class="pre">&#64;private</span></tt></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">成员变量应该声明为 <tt class="docutils literal"><span class="pre">&#64;private</span></tt></p>
</div>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@interface</span> <span class="nc">MyClass</span> : <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">id</span> <span class="n">myInstanceVariable_</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// public accessors, setter takes ownership</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">myInstanceVariable</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setMyInstanceVariable:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">theVar</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h4>明确指定构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">注释并且明确指定你的类的构造函数。</p>
</div>
<p>对于需要继承你的类的人来说，明确指定构造函数十分重要。这样他们就可以只重写一个构造函数（可能是几个）来保证他们的子类的构造函数会被调用。这也有助于将来别人调试你的类时，理解初始化代码的工作流程。</p>
</div>
<div class="section" id="id2">
<h4>重载指定构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当你写子类的时候，如果需要 <tt class="docutils literal"><span class="pre">init…</span></tt> 方法，记得重载父类的指定构造函数。</p>
</div>
<p>如果你没有重载父类的指定构造函数，你的构造函数有时可能不会被调用，这会导致非常隐秘而且难以解决的 bug。</p>
</div>
<div class="section" id="nsobject">
<h4>重载 <tt class="docutils literal"><span class="pre">NSObject</span></tt> 的方法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果重载了 <tt class="docutils literal"><span class="pre">NSObject</span></tt> 类的方法，强烈建议把它们放在 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 内的起始处，这也是常见的操作方法。</p>
</div>
<p>通常适用（但不局限）于 <tt class="docutils literal"><span class="pre">init...``，``copyWithZone:``，以及</span> <span class="pre">``dealloc</span></tt> 方法。所有 <tt class="docutils literal"><span class="pre">init...</span></tt> 方法应该放在一起，``copyWithZone:`` 紧随其后，最后才是 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 方法。</p>
</div>
<div class="section" id="id3">
<h4>初始化</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要在 init 方法中，将成员变量初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> 或者 <a href="#id4"><span class="problematic" id="id5">``</span></a>nil``；毫无必要。</p>
</div>
<p>刚分配的对象，默认值都是 0，除了 <tt class="docutils literal"><span class="pre">isa</span></tt> 指针（译者注：``NSObject`` 的 <tt class="docutils literal"><span class="pre">isa</span></tt> 指针，用于标识对象的类型）。所以不要在初始化器里面写一堆将成员初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> 或者 <tt class="docutils literal"><span class="pre">nil</span></tt> 的代码。</p>
</div>
<div class="section" id="new">
<h4>避免 <tt class="docutils literal"><span class="pre">+new</span></tt></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要调用 <tt class="docutils literal"><span class="pre">NSObject</span></tt> 类方法 <tt class="docutils literal"><span class="pre">new``，也不要在子类中重载它。使用</span> <span class="pre">``alloc</span></tt> 和 <tt class="docutils literal"><span class="pre">init</span></tt> 方法创建并初始化对象。</p>
</div>
<p>现代的 Ojbective-C 代码通过调用 <tt class="docutils literal"><span class="pre">alloc</span></tt> 和 <tt class="docutils literal"><span class="pre">init</span></tt> 方法来创建并 retain 一个对象。由于类方法 <tt class="docutils literal"><span class="pre">new</span></tt> 很少使用，这使得有关内存分配的代码审查更困难。</p>
</div>
<div class="section" id="api">
<h4>保持公共 API 简单</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">保持类简单；避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。用私有类别保证公共头文件整洁。</p>
</div>
<p>与 C++ 不同，Objective-C 没有方法来区分公共的方法和私有的方法 &#8211; 所有的方法都是公共的（译者注：这取决于 Objective-C 运行时的方法调用的消息机制）。因此，除非客户端的代码期望使用某个方法，不要把这个方法放进公共 API 中。尽可能的避免了你你不希望被调用的方法却被调用到。这包括重载父类的方法。对于内部实现所需要的方法，在实现的文件中定义一个类别，而不是把它们放进公有的头文件中。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// GTMFoo.m</span>
<span class="cp">#import &quot;GTMFoo.h&quot;</span>

<span class="k">@interface</span> <span class="nc">GTMFoo</span> <span class="nl">(PrivateDelegateHandling)</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">doSomethingWithDelegate</span><span class="p">;</span>  <span class="c1">// Declare private method</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">GTMFoo</span><span class="nl">(PrivateDelegateHandling)</span>
<span class="p">...</span>
<span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">doSomethingWithDelegate</span> <span class="p">{</span>
  <span class="c1">// Implement this method</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>Objective-C 2.0 以前，如果你在私有的 <tt class="docutils literal"><span class="pre">&#64;interface</span></tt> 中声明了某个方法，但在 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 中忘记定义这个方法，编译器不会抱怨（这是因为你没有在其它的类别中实现这个私有的方法）。解决文案是将方法放进指定类别的 <tt class="docutils literal"><span class="pre">&#64;implemenation</span></tt> 中。</p>
<p>如果你在使用 Objective-C 2.0，相反你应该使用 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_4_section_5.html">类扩展</a> 来声明你的私有类别，例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@interface</span> <span class="nc">GMFoo</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>这么做确保如果声明的方法没有在 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 中实现，会触发一个编译器告警。</p>
<p>再次说明，“私有的” 方法其实不是私有的。你有时可能不小心重载了父类的私有方法，因而制造出很难查找的 Bug。通常，私有的方法应该有一个相当特殊的名字以防止子类无意地重载它们。</p>
<p>Ojbective-C 的类别可以用来将一个大的 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 拆分成更容易理解的小块，同时，类别可以为最适合的类添加新的、特定应用程序的功能。例如，当添加一个 “middle truncation” 方法时，创建一个 <tt class="docutils literal"><span class="pre">NSString</span></tt> 的新类别并把方法放在里面，要比创建任意的一个新类把方法放进里面好得多。</p>
</div>
<div class="section" id="import-and-include">
<h4><tt class="docutils literal"><span class="pre">#import</span></tt> and <tt class="docutils literal"><span class="pre">#include</span></tt></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">#import</span></tt> Ojbective-C/Objective-C++ 头文件，``#include`` C/C++ 头文件。</p>
</div>
<p>基于你所包括的头文件的编程语言，选择使用 <tt class="docutils literal"><span class="pre">#import</span></tt> 或是 <a href="#id7"><span class="problematic" id="id8">``</span></a>#include``：</p>
<ul class="simple">
<li>当包含一个使用 Objective-C、Objective-C++ 的头文件时，使用 <tt class="docutils literal"><span class="pre">#import</span></tt> 。</li>
<li>当包含一个使用标准 C、C++ 头文件时，使用 <a href="#id9"><span class="problematic" id="id10">``</span></a>#include``。头文件应该使用 <a href="#id11"><span class="problematic" id="id12">`</span></a>#define 保护 &lt;<a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=The__define_Guard#The__define_Guard">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=The__define_Guard#The__define_Guard</a>&gt;`_。</li>
</ul>
<p>一些 Ojbective-C 的头文件缺少 <tt class="docutils literal"><span class="pre">#define</span></tt> 保护，需要使用 <tt class="docutils literal"><span class="pre">#import</span></tt> 的方式包含。由于 Objective-C 的头文件只会被 Objective-C 的源文件及头文件包含，广泛地使用 <tt class="docutils literal"><span class="pre">#import</span></tt> 是可以的。</p>
<p>文件中没有 Objective-C 代码的标准 C、C++ 头文件，很可能会被普通的 C、C++ 包含。由于标准 C、C++ 里面没有 <tt class="docutils literal"><span class="pre">#import</span></tt> 的用法，这些文件将被 <tt class="docutils literal"><span class="pre">#include``。在</span> <span class="pre">Objective-C</span> <span class="pre">源文件中使用</span> <span class="pre">``#include</span></tt> 包含这些头文件，意味着这些头文件永远会在相同的语义下包含。</p>
<p>这条规则帮助跨平台的项目避免低级错误。某个 Mac 开发者写了一个新的 C 或 C++ 头文件，如果忘记使用 <tt class="docutils literal"><span class="pre">#define</span></tt> 保护，在 Mac 下使用 <tt class="docutils literal"><span class="pre">#import</span></tt> 这个头文件不回引起问题，但是在其它平台下使用 <tt class="docutils literal"><span class="pre">#include</span></tt> 将可能编译失败。在所有的平台上统一使用 <a href="#id13"><span class="problematic" id="id14">``</span></a>#include``，意味着构造更可能全都成功或者失败，防止这些文件只能在某些平台下能够工作。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="cp">#import &lt;Cocoa/Cocoa.h&gt;</span>
<span class="cp">#include &lt;CoreFoundation/CoreFoundation.h&gt;</span>
<span class="cp">#import &quot;GTMFoo.h&quot;</span>
<span class="cp">#include &quot;base/basictypes.h&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4>使用根框架</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">#import</span></tt> 根框架而不是单独的零散文件</p>
</div>
<p>当你试图从框架（如 Cocoa 或者 Foundation）中包含若干零散的系统头文件时，实际上包含顶层根框架的话，编译器要做的工作更少。根框架通常已经经过预编译，加载更快。另外记得使用 <tt class="docutils literal"><span class="pre">#import</span></tt> 而不是 <tt class="docutils literal"><span class="pre">#include</span></tt> 来包含 Objective-C 的框架。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="cp">#import &lt;Foundation/Foundation.h&gt;     </span><span class="c1">// good</span>

<span class="cp">#import &lt;Foundation/NSArray.h&gt;        </span><span class="c1">// avoid</span>
<span class="cp">#import &lt;Foundation/NSString.h&gt;</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="autorelease">
<h4>构建时即设定 <tt class="docutils literal"><span class="pre">autorelease</span></tt></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当创建临时对象时，在同一行使用 <a href="#id16"><span class="problematic" id="id17">``</span></a>autolease``，而不是在同一个方法的后面语句中使用一个单独的 <a href="#id18"><span class="problematic" id="id19">``</span></a>release``。</p>
</div>
<p>尽管运行效率会差一点，但避免了意外删除 <tt class="docutils literal"><span class="pre">release</span></tt> 或者插入 <tt class="docutils literal"><span class="pre">return</span></tt> 语句而导致内存泄露的可能。例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// AVOID (unless you have a compelling performance reason)</span>
<span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="c1">// ... code here that might return ...</span>
<span class="p">[</span><span class="n">controller</span> <span class="n">release</span><span class="p">];</span>

<span class="c1">// BETTER</span>
<span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="autorelease-retain">
<h4><tt class="docutils literal"><span class="pre">autorelease</span></tt> 优先 <tt class="docutils literal"><span class="pre">retain</span></tt> 其次</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">给对象赋值时遵守 <tt class="docutils literal"><span class="pre">autorelease``之后</span> <span class="pre">``retain</span></tt> 的模式。</p>
</div>
<p>当给一个变量赋值新的对象时，必须先释放掉旧的对象以避免内存泄露。有很多 “正确的” 方法可以处理这种情况。我们则选择 “<tt class="docutils literal"><span class="pre">autorelease</span></tt> 之后 <tt class="docutils literal"><span class="pre">retain</span></tt>” 的方法，因为事实证明它不容易出错。注意大的循环会填满 <tt class="docutils literal"><span class="pre">autorelease</span></tt> 池，并且可能效率上会差一点，但权衡之下我们认为是可以接受的。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFoo:</span><span class="p">(</span><span class="n">GMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">aFoo</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">foo_</span> <span class="n">autorelease</span><span class="p">];</span>  <span class="c1">// Won&#39;t dealloc if |foo_| == |aFoo|</span>
  <span class="n">foo_</span> <span class="o">=</span> <span class="p">[</span><span class="n">aFoo</span> <span class="n">retain</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="init-dealloc">
<h4><tt class="docutils literal"><span class="pre">init</span></tt> 和 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 内避免使用访问器</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 <tt class="docutils literal"><span class="pre">init</span></tt> 和 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 方法执行的过程中，子类可能会处在一个不一致的状态，所以这些方法中的代码应避免调用访问器。</p>
</div>
<p>子类尚未初始化，或在 <tt class="docutils literal"><span class="pre">init</span></tt> 和 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 方法执行时已经被销毁，会使访问器方法很可能不可靠。实际上，应在这些方法中直接对 ivals 进行赋值或释放操作。</p>
<p>正确：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bar_</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>  <span class="c1">// good</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="n">release</span><span class="p">];</span>                           <span class="c1">// good</span>
  <span class="p">[</span><span class="n">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="n">string</span><span class="p">];</span>  <span class="c1">// avoid</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="n">self</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>                         <span class="c1">// avoid</span>
  <span class="p">[</span><span class="n">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h4>按声明顺序销毁实例变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">dealloc</span></tt> 中实例变量被释放的顺序应该与它们在 <tt class="docutils literal"><span class="pre">&#64;interface</span></tt> 中声明的顺序一致，这有助于代码审查。</p>
</div>
<p>代码审查者在评审新的或者修改过的 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 实现时，需要保证每个 <tt class="docutils literal"><span class="pre">retained</span></tt> 的实例变量都得到了释放。</p>
<p>为了简化 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 的审查，``retained`` 实例变量被释放的顺序应该与他们在 <tt class="docutils literal"><span class="pre">&#64;interface</span></tt> 中声明的顺序一致。如果 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 调用了其它方法释放成员变量，添加注释解释这些方法释放了哪些实例变量。</p>
</div>
<div class="section" id="setter-nsstrings">
<h4><tt class="docutils literal"><span class="pre">setter</span></tt> 应复制 NSStrings</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">接受 <tt class="docutils literal"><span class="pre">NSString</span></tt> 作为参数的 <tt class="docutils literal"><span class="pre">setter``，应该总是</span> <span class="pre">``copy</span></tt> 传入的字符串。</p>
</div>
<p>永远不要仅仅 <tt class="docutils literal"><span class="pre">retain</span></tt> 一个字符串。因为调用者很可能在你不知情的情况下修改了字符串。不要假定别人不会修改，你接受的对象是一个 <tt class="docutils literal"><span class="pre">NSString</span></tt> 对象而不是 <tt class="docutils literal"><span class="pre">NSMutableString</span></tt> 对象。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFoo:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">aFoo</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">foo_</span> <span class="n">autorelease</span><span class="p">];</span>
  <span class="n">foo_</span> <span class="o">=</span> <span class="p">[</span><span class="n">aFoo</span> <span class="n">copy</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="avoid-throwing-exceptions">
<span id="id21"></span><h4>避免抛异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要 <tt class="docutils literal"><span class="pre">&#64;throw</span></tt> Objective-C 异常，同时也要时刻准备捕获从第三方或 OS 代码中抛出的异常。</p>
</div>
<p>我们的确允许 <tt class="docutils literal"><span class="pre">-fobjc-exceptions</span></tt> 编译开关（主要因为我们要用到 <tt class="docutils literal"><span class="pre">&#64;synchronized</span></tt> ），但我们不使用 <tt class="docutils literal"><span class="pre">&#64;throw``。为了合理使用第三方的代码，``&#64;try``、``&#64;catch</span></tt> 和 <tt class="docutils literal"><span class="pre">&#64;finally</span></tt> 是允许的。如果你确实使用了异常，请明确注释你期望什么方法抛出异常。</p>
<p>不要使用 <tt class="docutils literal"><span class="pre">NS_DURING``、``NS_HANDLER``、``NS_ENDHANDLER``、``NS_VALUERETURN</span></tt> 和 <tt class="docutils literal"><span class="pre">NS_VOIDRETURN</span></tt> 宏，除非你写的代码需要在 Mac OS X 10.2 或之前的操作系统中运行。</p>
<p>注意：如果抛出 Objective-C 异常，Objective-C++ 代码中基于栈的对象不会被销毁。比如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="n">class</span> <span class="n">exceptiontest</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">exceptiontest</span><span class="p">()</span> <span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Created&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="o">~</span><span class="n">exceptiontest</span><span class="p">()</span> <span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Destroyed&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">exceptiontest</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">NSException</span> <span class="o">*</span><span class="n">exception</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSException</span> <span class="n">exceptionWithName</span><span class="o">:</span><span class="s">@&quot;foo&quot;</span>
                                                   <span class="nl">reason:</span><span class="s">@&quot;bar&quot;</span>
                                                 <span class="nl">userInfo:</span><span class="nb">nil</span><span class="p">];</span>
  <span class="k">@throw</span> <span class="n">exception</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">GMAutoreleasePool</span> <span class="n">pool</span><span class="p">;</span>
  <span class="k">@try</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">@catch</span><span class="p">(</span><span class="n">NSException</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;exception raised&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>会输出：</p>
<p>注意：这里析构函数从未被调用。这主要会影响基于栈的 <tt class="docutils literal"><span class="pre">smartptr``，比如</span> <span class="pre">``shared_ptr``、``linked_ptr``，以及所有你可能用到的</span> <span class="pre">STL</span> <span class="pre">对象。因此我们不得不痛苦的说，如果必须在</span> <span class="pre">Objective-C++</span> <span class="pre">中使用异常，就只用</span> <span class="pre">C++</span> <span class="pre">的异常机制。永远不应该重新抛出</span> <span class="pre">Objective-C</span> <span class="pre">异常，也不应该在</span> <span class="pre">``&#64;try``、``&#64;catch</span></tt> 或 <tt class="docutils literal"><span class="pre">&#64;finally</span></tt> 语句块中使用基于栈的 C++ 对象。</p>
</div>
<div class="section" id="nil">
<h4>nil 检查</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">nil</span></tt> 检查只用在逻辑流程中。</p>
</div>
<p>使用 <tt class="docutils literal"><span class="pre">nil</span></tt> 的检查来检查应用程序的逻辑流程，而不是避免崩溃。Objective-C 运行时会处理向 <tt class="docutils literal"><span class="pre">nil</span></tt> 对象发送消息的情况。如果方法没有返回值，就没关系。如果有返回值，可能由于运行时架构、返回值类型以及 OS X 版本的不同而不同，参见 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_2_section_3.html">Apple’s documentation</a> 。</p>
<p>注意，这和 C/C++ 中检查指针是否为 ‵‵NULL`` 很不一样，C/C++ 运行时不做任何检查，从而导致应用程序崩溃。因此你仍然需要保证你不会对一个 C/C++ 的空指针解引用。</p>
</div>
<div class="section" id="bool">
<h4>BOOL 若干陷阱</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将普通整形转换成 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 时要小心。不要直接将 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 值与 <tt class="docutils literal"><span class="pre">YES</span></tt> 进行比较。</p>
</div>
<p>Ojbective-C 中把 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 定义成无符号字符型，这意味着 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 类型的值远不止 <tt class="docutils literal"><span class="pre">YES``(1)或</span> <span class="pre">``NO``(0)。不要直接把整形转换成</span> <span class="pre">``BOOL``。常见的错误包括将数组的大小、指针值及位运算的结果直接转换成</span> <span class="pre">``BOOL</span></tt> ，取决于整型结果的最后一个字节，很可能会产生一个 <tt class="docutils literal"><span class="pre">NO</span></tt> 值。当转换整形至 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 时，使用三目操作符来返回 <tt class="docutils literal"><span class="pre">YES</span></tt> 或者 <a href="#id22"><span class="problematic" id="id23">``</span></a>NO``。（译者注：读者可以试一下任意的 256 的整数的转换结果，如 256、512 …）</p>
<p>你可以安全在 <tt class="docutils literal"><span class="pre">BOOL``、``_Bool</span></tt> 以及 <tt class="docutils literal"><span class="pre">bool</span></tt> 之间转换（参见 C++ Std 4.7.4, 4.12 以及 C99 Std 6.3.1.2）。你不能安全在 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 以及 <tt class="docutils literal"><span class="pre">Boolean</span></tt> 之间转换，因此请把 <tt class="docutils literal"><span class="pre">Boolean</span></tt> 当作一个普通整形，就像之前讨论的那样。但 Objective-C 的方法标识符中，只使用 <a href="#id24"><span class="problematic" id="id25">``</span></a>BOOL``。</p>
<p>对 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 使用逻辑运算符（``&amp;&amp;``，``||`` 和 <a href="#id26"><span class="problematic" id="id27">``</span></a>!``）是合法的，返回值也可以安全地转换成 <a href="#id28"><span class="problematic" id="id29">``</span></a>BOOL``，不需要使用三目操作符。</p>
<p>错误的用法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isBold</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">fontTraits</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">NSFontBoldTrait</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isValid</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">stringValue</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>正确的用法：</p>
<blockquote>
<div><div class="highlight-objc"><div class="highlight"><pre>
</pre></div>
</div>
<ul class="simple">
<li>(BOOL)isBold {
return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;</li>
</ul>
<p>}
- (BOOL)isValid {</p>
<blockquote>
<div>return [self stringValue] != nil;</div></blockquote>
<p>}
- (BOOL)isEnabled {</p>
<blockquote>
<div>return [self isValid] &amp;&amp; [self isBold];</div></blockquote>
<p>}</p>
</div></blockquote>
<p>同样，不要直接比较 <tt class="docutils literal"><span class="pre">YES/NO</span></tt> 和 <tt class="docutils literal"><span class="pre">BOOL</span></tt> 变量。不仅仅因为影响可读性，更重要的是结果可能与你想的不同。</p>
<p>错误的用法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="kt">BOOL</span> <span class="n">great</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">isGreat</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">great</span> <span class="o">==</span> <span class="nb">YES</span><span class="p">)</span>
  <span class="c1">// ...be great!</span>
</pre></div>
</div>
<p>正确的用法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="kt">BOOL</span> <span class="n">great</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">isGreat</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">great</span><span class="p">)</span>
  <span class="c1">// ...be great!</span>
</pre></div>
</div>
</div>
<div class="section" id="property">
<h4>属性（Property）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">属性（Property）通常允许使用，但需要清楚的了解：属性（Property）是 Objective-C 2.0 的特性，会限制你的代码只能跑在 iPhone 和 Mac OS X 10.5 (Leopard) 及更高版本上。点引用只允许访问声明过的 <a href="#id30"><span class="problematic" id="id31">``</span></a>&#64;property``。</p>
</div>
<div class="section" id="id32">
<h5>命名</h5>
<p>属性所关联的实例变量的命名必须遵守以下划线作为后缀的规则。属性的名字应该与成员变量去掉下划线后缀的名字一模一样。</p>
<p>使用 <tt class="docutils literal"><span class="pre">&#64;synthesize</span></tt> 指示符来正确地重命名属性。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@interface</span> <span class="nc">MyClass</span> : <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">name_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">MyClass</span>
<span class="k">@synthesize</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h5>位置</h5>
<p>属性的声明必须紧靠着类接口中的实例变量语句块。属性的定义必须在 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 的类定义的最上方。他们的缩进与包含他们的 <tt class="docutils literal"><span class="pre">&#64;interface</span></tt> 以及 <tt class="docutils literal"><span class="pre">&#64;implementation</span></tt> 语句一样。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="k">@interface</span> <span class="nc">MyClass</span> : <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">name_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">MyClass</span>
<span class="k">@synthesize</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="copy-attribute">
<h5>字符串应使用 <tt class="docutils literal"><span class="pre">copy</span></tt> 属性（Attribute）</h5>
<p>应总是用 <tt class="docutils literal"><span class="pre">copy</span></tt> 属性（attribute）声明 <tt class="docutils literal"><span class="pre">NSString</span></tt> 属性（property）。</p>
<p>从逻辑上，确保遵守 <tt class="docutils literal"><span class="pre">NSString</span></tt> 的 <tt class="docutils literal"><span class="pre">setter</span></tt> 必须使用 <tt class="docutils literal"><span class="pre">copy</span></tt> 而不是 <tt class="docutils literal"><span class="pre">retain</span></tt> 的原则。</p>
</div>
<div class="section" id="id34">
<h5>原子性</h5>
<p>一定要注意属性（property）的开销。缺省情况下，所有 <tt class="docutils literal"><span class="pre">synthesize</span></tt> 的 <tt class="docutils literal"><span class="pre">setter</span></tt> 和 <tt class="docutils literal"><span class="pre">getter</span></tt> 都是原子的。这会给每个 <tt class="docutils literal"><span class="pre">get</span></tt> 或者 <tt class="docutils literal"><span class="pre">set</span></tt> 带来一定的同步开销。将属性（property）声明为 <a href="#id35"><span class="problematic" id="id36">``</span></a>nonatomic``，除非你需要原子性。</p>
</div>
<div class="section" id="id37">
<h5>点引用</h5>
<p>点引用是地道的 Objective-C 2.0 风格。它被使用于简单的属性 <tt class="docutils literal"><span class="pre">set``、``get</span></tt> 操作，但不应该用它来调用对象的其它操作。</p>
<p>正确的做法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="n">NSString</span> <span class="o">*</span><span class="n">oldName</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="n">myObject</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Alice&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>错误的做法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSArray</span> <span class="n">arrayWithObject</span><span class="o">:</span><span class="s">@&quot;hello&quot;</span><span class="p">]</span> <span class="n">retain</span><span class="p">];</span>

<span class="n">NSUInteger</span> <span class="n">numberOfItems</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>  <span class="c1">// not a property</span>
<span class="n">array</span><span class="p">.</span><span class="n">release</span><span class="p">;</span>                           <span class="c1">// not a property</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id38">
<h4>没有实例变量的接口</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">没有声明任何实例变量的接口，应省略空花括号。</p>
</div>
<p>正确的做法：</p>
<blockquote>
<div>&#64;interface MyClass : NSObject
// Does a lot of stuff
- (void)fooBarBam;
&#64;end</div></blockquote>
<p>错误的做法：</p>
<blockquote>
<div>&#64;interface MyClass : NSObject {
}
// Does a lot of stuff
- (void)fooBarBam;
&#64;end</div></blockquote>
</div>
<div class="section" id="synthesize">
<h4>自动 <tt class="docutils literal"><span class="pre">synthesize</span></tt> 实例变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只运行在 iOS 下的代码，优先考虑使用自动 <tt class="docutils literal"><span class="pre">synthesize</span></tt> 实例变量。</p>
</div>
<p><tt class="docutils literal"><span class="pre">synthesize</span></tt> 实例变量时，使用 <tt class="docutils literal"><span class="pre">&#64;synthesize</span> <span class="pre">var</span> <span class="pre">=</span> <span class="pre">var_;</span></tt> 防止原本想调用 <tt class="docutils literal"><span class="pre">self.var</span> <span class="pre">=</span> <span class="pre">blah;</span></tt> 却不慎写成了 <a href="#id39"><span class="problematic" id="id40">``</span></a>var = blah;``。</p>
<p>不要synthesize CFType的属性 CFType应该永远使用&#64;dynamic实现指示符。 尽管CFType不能使用retain属性特性，开发者必须自己处理retain和release。很少有情况你需要仅仅对它进行赋值，因此最好显示地实现getter和setter，并作出注释说明。 列出所有的实现指示符 尽管&#64;dynamic是默认的，显示列出它以及其它的实现指示符会提高可读性，代码阅读者可以一眼就知道类的每个属性是如何实现的。</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="c1">// Header file</span>
<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
<span class="c1">// A guy walks into a bar.</span>
<span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// Implementation file</span>
<span class="k">@interface</span> <span class="nc">Foo</span> <span class="p">()</span>
<span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">retain</span><span class="p">)</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">baz</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="k">@synthesize</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">bar_</span><span class="p">;</span>
<span class="k">@synthesize</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">baz_</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/patterns"></span><div class="section" id="cocoa">
<h3>Cocoa 模式</h3>
<div class="section" id="id1">
<h4>委托模式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">委托对象不应该被 <tt class="docutils literal"><span class="pre">retain</span></tt></p>
</div>
<p>实现委托模式的类应：</p>
<ol class="arabic simple">
<li>拥有一个名为 <tt class="docutils literal"><span class="pre">delegate_</span></tt> 的实例变量来引用委托。</li>
<li>因此，访问器方法应该命名为 <tt class="docutils literal"><span class="pre">delegate</span></tt> 和 <a href="#id2"><span class="problematic" id="id3">``</span></a>setDelegate:<a href="#id4"><span class="problematic" id="id5">``</span></a>。</li>
<li><tt class="docutils literal"><span class="pre">delegate_</span></tt> 对象不应该被 <a href="#id6"><span class="problematic" id="id7">``</span></a>retain``。</li>
</ol>
</div>
<div class="section" id="mvc">
<h4>模型/视图/控制器（MVC）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">分离模型与视图。分离控制器与视图、模型。回调 API 使用 <a href="#id8"><span class="problematic" id="id9">``</span></a>&#64;protocol``。</p>
</div>
<ul class="simple">
<li>分离模型与视图：不要假设模型或者数据源的表示方法。保持数据源与表示层之间的接口抽象。视图不需要了解模型的逻辑（主要的规则是问问你自己，对于数据源的一个实例，有没有可能有多种不同状态的表示方法）。</li>
<li>分离控制器与模型、视图：不要把所有的 “业务逻辑” 放进跟视图有关的类中。这使代码非常难以复用。使用控制器类来处理这些代码，但保证控制器不需要了解太多表示层的逻辑。</li>
<li>使用 <tt class="docutils literal"><span class="pre">&#64;protocol</span></tt> 来定义回调 API，如果不是所有的方法都必须实现，使用 <tt class="docutils literal"><span class="pre">&#64;optional``（特例：使用</span> <span class="pre">Objective-C</span> <span class="pre">1.0</span> <span class="pre">时，``&#64;optional</span></tt> 不可用，可使用类别来定义一个 “非正规的协议”）。</li>
</ul>
</div>
</div>
</div>
</div>
<span id="document-google-python-styleguide/contents"></span><div class="section" id="python">
<span id="python-contents"></span><h2>Python 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-python-styleguide/index"></span><div class="section" id="google-python">
<h3>Google Python 风格指南 - 中文版</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">2.19</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Amit Patel</div>
<div class="line">Antoine Picard</div>
<div class="line">Eugene Jhong</div>
<div class="line">Jeremy Hylton</div>
<div class="line">Matt Smart</div>
<div class="line">Mike Shields</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://guoqiao.me/">guoqiao</a></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="http://google-styleguide.googlecode.com">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="id1">
<h4>目录</h4>
<div class="toctree-wrapper compound">
<span id="document-google-python-styleguide/python_language_rules"></span><div class="section" id="python">
<h5>Python语言规范</h5>
<div class="section" id="pychecker">
<h6>pychecker</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对你的代码运行pychecker</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>pychecker是一个在Python源代码中查找bug的工具. 对于C和C++这样的不那么动态的(译者注: 原文是less dynamic)语言, 这些bug通常由编译器来捕获. pychecker和lint类似. 由于Python的动态特性, 有些警告可能不对. 不过伪告警应该很少.</dd>
<dt>优点:</dt>
<dd>可以捕获容易忽视的错误, 例如输入错误, 使用未赋值的变量等.</dd>
<dt>缺点:</dt>
<dd>pychecker不完美. 要利用其优势, 我们有时侯需要: a) 围绕着它来写代码 b) 抑制其告警 c) 改进它, 或者d) 忽略它.</dd>
<dt>结论:</dt>
<dd><p class="first">确保对你的代码运行pychecker.</p>
<p>关于如何运行pychecker的更多信息, 参考 <a class="reference external" href="http://pychecker.sourceforge.net/">pychecker主页</a></p>
<p>你可以设置一个叫做__pychecker__的模块级变量来抑制适当的告警. 例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">__pychecker__</span> <span class="o">=</span> <span class="s">&#39;no-callinit no-classattr&#39;</span>
</pre></div>
</div>
<p>采用这种抑制方式的好处是我们可以轻松查找抑制并回顾它们.</p>
<p>你可以使用 <tt class="docutils literal"><span class="pre">pychecker</span> <span class="pre">--help</span></tt> 来获取pychecker告警列表.</p>
<p>要抑制&#8221;参数未使用&#8221;告警, 你可以用&#8221;_&#8221;作为参数标识符, 或者在参数名前加&#8221;unused_&#8221;. 遇到不能改变参数名的情况, 你可以通过在函数开头&#8221;提到&#8221;它们来消除告警. 例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unused_b</span><span class="p">,</span> <span class="n">unused_c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>  <span class="c"># 让pychecker不告警</span>
    <span class="k">return</span> <span class="n">a</span>
</pre></div>
</div>
<p class="last">理想情况下, 我们以后会扩展pychecker以确保你真的没有使用这些参数.</p>
</dd>
</dl>
</div>
<div class="section" id="id2">
<h6>导入</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">仅对包和模块使用导入</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>模块间共享代码的重用机制.</dd>
<dt>优点:</dt>
<dd>命名空间管理约定十分简单. 每个标识符的源都用一种一致的方式指示. x.Obj表示Obj对象定义在模块x中.</dd>
<dt>缺点:</dt>
<dd>模块名仍可能冲突. 有些模块名太长, 不太方便.</dd>
<dt>结论:</dt>
<dd><p class="first">使用 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">x</span></tt> 来导入包和模块.</p>
<p>使用 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">x</span> <span class="pre">import</span> <span class="pre">y</span></tt> , 其中x是包前缀, y是不带前缀的模块名.</p>
<p>使用 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">x</span> <span class="pre">import</span> <span class="pre">y</span> <span class="pre">as</span> <span class="pre">z</span></tt>, 如果两个要导入的模块都叫做z或者y太长了.</p>
<p>例如, 模块 <tt class="docutils literal"><span class="pre">sound.effects.echo</span></tt> 可以用如下方式导入:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="n">echo</span>
<span class="o">...</span>
<span class="n">echo</span><span class="o">.</span><span class="n">EchoFilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">导入时不要使用相对名称. 即使模块在同一个包中, 也要使用完整包名. 这能帮助你避免无意间导入一个包两次.</p>
</dd>
</dl>
</div>
<div class="section" id="id3">
<h6>包</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用模块的全路径名来导入每个模块</p>
</div>
<dl class="docutils">
<dt>优点:</dt>
<dd>避免模块名冲突. 查找包更容易.</dd>
<dt>缺点:</dt>
<dd>部署代码变难, 因为你必须复制包层次.</dd>
<dt>结论:</dt>
<dd><p class="first">所有的新代码都应该用完整包名来导入每个模块.</p>
<p>应该像下面这样导入:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c"># Reference in code with complete name.</span>
<span class="kn">import</span> <span class="nn">sound.effects.echo</span>

<span class="c"># Reference in code with just module name (preferred).</span>
<span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="n">echo</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id4">
<h6>异常</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">允许使用异常, 但必须小心</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>异常是一种跳出代码块的正常控制流来处理错误或者其它异常条件的方式.</dd>
<dt>优点:</dt>
<dd>正常操作代码的控制流不会和错误处理代码混在一起. 当某种条件发生时, 它也允许控制流跳过多个框架. 例如, 一步跳出N个嵌套的函数, 而不必继续执行错误的代码.</dd>
<dt>缺点:</dt>
<dd>可能会导致让人困惑的控制流. 调用库时容易错过错误情况.</dd>
<dt>结论:</dt>
<dd><p class="first">异常必须遵守特定条件:</p>
<ol class="last arabic">
<li><p class="first">像这样触发异常: <tt class="docutils literal"><span class="pre">raise</span> <span class="pre">MyException(&quot;Error</span> <span class="pre">message&quot;)</span></tt> 或者 <tt class="docutils literal"><span class="pre">raise</span> <span class="pre">MyException</span></tt> . 不要使用两个参数的形式( <tt class="docutils literal"><span class="pre">raise</span> <span class="pre">MyException,</span> <span class="pre">&quot;Error</span> <span class="pre">message&quot;</span></tt> )或者过时的字符串异常( <tt class="docutils literal"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">message&quot;</span></tt> ).</p>
</li>
<li><p class="first">模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的Exception类继承. 模块的异常基类应该叫做&#8221;Error&#8221;.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">永远不要使用 <tt class="docutils literal"><span class="pre">except:</span></tt> 语句来捕获所有异常, 也不要捕获 <tt class="docutils literal"><span class="pre">Exception</span></tt> 或者 <tt class="docutils literal"><span class="pre">StandardError</span></tt> , 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容, <tt class="docutils literal"><span class="pre">except:</span></tt> 真的会捕获包括Python语法错误在内的任何错误. 使用 <tt class="docutils literal"><span class="pre">except:</span></tt> 很容易隐藏真正的bug.</p>
</li>
<li><p class="first">尽量减少try/except块中的代码量. try块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, try/except块将隐藏真正的错误.</p>
</li>
<li><p class="first">使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件.</p>
</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h6>全局变量</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">避免全局变量</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>定义在模块级的变量.</dd>
<dt>优点:</dt>
<dd>偶尔有用.</dd>
<dt>缺点:</dt>
<dd>导入时可能改变模块行为, 因为导入模块时会对模块级变量赋值.</dd>
<dt>结论:</dt>
<dd><p class="first">避免使用全局变量, 用类变量来代替. 但也有一些例外:</p>
<ol class="last arabic simple">
<li>脚本的默认选项.</li>
<li>模块级常量. 例如:　PI = 3.14159. 常量应该全大写, 用下划线连接.</li>
<li>有时候用全局变量来缓存值或者作为函数返回值很有用.</li>
<li>如果需要, 全局变量应该仅在模块内部可用, 并通过模块级的公共函数来访问.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="id6">
<h6>嵌套/局部/内部类或函数</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">鼓励使用嵌套/本地/内部类或函数</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>类可以定义在方法, 函数或者类中. 函数可以定义在方法或函数中. 封闭区间中定义的变量对嵌套函数是只读的.</dd>
<dt>优点:</dt>
<dd>允许定义仅用于有效范围的工具类和函数.</dd>
<dt>缺点:</dt>
<dd>嵌套类或局部类的实例不能序列化(pickled).</dd>
<dt>结论:</dt>
<dd>推荐使用.</dd>
</dl>
</div>
<div class="section" id="list-comprehensions">
<h6>列表推导(List Comprehensions)</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以在简单情况下使用</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>列表推导(list comprehensions)与生成器表达式(generator expression)提供了一种简洁高效的方式来创建列表和迭代器, 而不必借助map(), filter(), 或者lambda.</dd>
<dt>优点:</dt>
<dd>简单的列表推导可以比其它的列表创建方法更加清晰简单. 生成器表达式可以十分高效, 因为它们避免了创建整个列表.</dd>
<dt>缺点:</dt>
<dd>复杂的列表推导或者生成器表达式可能难以阅读.</dd>
<dt>结论:</dt>
<dd><p class="first">适用于简单情况. 每个部分应该单独置于一行: 映射表达式, for语句, 过滤器表达式. 禁止多重for语句或过滤器表达式. 复杂情况下还是使用循环.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span>
          <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
              <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
              <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                  <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span><span class="p">:</span>
                      <span class="k">yield</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">complicated_transform</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">long_generator_function</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>

  <span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

  <span class="n">eat</span><span class="p">(</span><span class="n">jelly_bean</span> <span class="k">for</span> <span class="n">jelly_bean</span> <span class="ow">in</span> <span class="n">jelly_beans</span>
      <span class="k">if</span> <span class="n">jelly_bean</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s">&#39;black&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h6>默认迭代器和操作符</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果类型支持, 就使用默认迭代器和操作符. 比如列表, 字典及文件等.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>容器类型, 像字典和列表, 定义了默认的迭代器和关系测试操作符(in和not in)</dd>
<dt>优点:</dt>
<dd>默认操作符和迭代器简单高效, 它们直接表达了操作, 没有额外的方法调用. 使用默认操作符的函数是通用的. 它可以用于支持该操作的任何类型.</dd>
<dt>缺点:</dt>
<dd>你没法通过阅读方法名来区分对象的类型(例如, has_key()意味着字典). 不过这也是优点.</dd>
<dt>结论:</dt>
<dd><p class="first">如果类型支持, 就使用默认迭代器和操作符, 例如列表, 字典和文件. 内建类型也定义了迭代器方法. 优先考虑这些方法, 而不是那些返回列表的方法. 当然，这样遍历容器时，你将不能修改容器.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span>  <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adict</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adict</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">afile</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>   <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="o">...</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">adict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="o">...</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">afile</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h6>生成器</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">按需使用生成器.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>所谓生成器函数, 就是每当它执行一次生成(yield)语句, 它就返回一个迭代器, 这个迭代器生成一个值. 生成值后, 生成器函数的运行状态将被挂起, 直到下一次生成.</dd>
<dt>优点:</dt>
<dd>简化代码, 因为每次调用时, 局部变量和控制流的状态都会被保存. 比起一次创建一系列值的函数, 生成器使用的内存更少.</dd>
<dt>缺点:</dt>
<dd>没有.</dd>
<dt>结论:</dt>
<dd>鼓励使用. 注意在生成器函数的文档字符串中使用&#8221;Yields:&#8221;而不是&#8221;Returns:&#8221;.</dd>
</dl>
</div>
<div class="section" id="lambda">
<h6>Lambda函数</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于单行函数</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>与语句相反, lambda在一个表达式中定义匿名函数. 常用于为map()和filter()之类的高阶函数定义回调函数或者操作符.</dd>
<dt>优点:</dt>
<dd>方便.</dd>
<dt>缺点:</dt>
<dd>比本地函数更难阅读和调试. 没有函数名意味着堆栈跟踪更难理解. 由于lambda函数通常只包含一个表达式, 因此其表达能力有限.</dd>
<dt>结论:</dt>
<dd>适用于单行函数. 如果代码超过60-80个字符, 最好还是定义成常规(嵌套)函数.</dd>
</dl>
</div>
<div class="section" id="id9">
<h6>默认参数值</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于大部分情况.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>你可以在函数参数列表的最后指定变量的值, 例如, <tt class="docutils literal"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">0):</span></tt> . 如果调用foo时只带一个参数, 则b被设为0. 如果带两个参数, 则b的值等于第二个参数.</dd>
<dt>优点:</dt>
<dd>你经常会碰到一些使用大量默认值的函数, 但偶尔(比较少见)你想要覆盖这些默认值. 默认参数值提供了一种简单的方法来完成这件事, 你不需要为这些罕见的例外定义大量函数. 同时, Python也不支持重载方法和函数, 默认参数是一种&#8221;仿造&#8221;重载行为的简单方式.</dd>
<dt>缺点:</dt>
<dd>默认参数只在模块加载时求值一次. 如果参数是列表或字典之类的可变类型, 这可能会导致问题. 如果函数修改了对象(例如向列表追加项), 默认值就被修改了.</dd>
<dt>结论:</dt>
<dd><p class="first">鼓励使用, 不过有如下注意事项:</p>
<p>不要在函数或方法定义中使用可变对象作为默认值.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
             <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[]):</span>
         <span class="o">...</span>
</pre></div>
</div>
<p>调用方代码必须为带有默认值的参数使用带有名字的值. 这多少能增加代码的可读性, 并且当增加参数时能避免和检测接口被破坏.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="properties">
<h6>属性(properties)</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">访问和设置数据成员时, 你通常会使用简单, 轻量级的访问和设置函数. 建议用属性（properties）来代替它们.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>一种用于包装方法调用的方式. 当运算量不大, 它是获取和设置属性(attribute)的标准方式.</dd>
<dt>优点:</dt>
<dd>通过消除简单的属性(attribute)访问时显式的get和set方法调用, 可读性提高了. 允许懒惰的计算. 用Pythonic的方式来维护类的接口. 就性能而言, 当直接访问变量是合理的, 添加访问方法就显得琐碎而无意义. 使用属性(properties)可以绕过这个问题. 将来也可以在不破坏接口的情况下将访问方法加上.</dd>
<dt>缺点:</dt>
<dd>属性(properties)是在get和set方法声明后指定, 这需要使用者在接下来的代码中注意: set和get是用于属性(properties)的(除了用&#64;property装饰器创建的只读属性).  必须继承自object类. 可能隐藏比如操作符重载之类的副作用. 继承时可能会让人困惑.</dd>
<dt>结论:</dt>
<dd><p class="first">你通常习惯于使用访问或设置方法来访问或设置数据, 它们简单而轻量. 不过我们建议你在新的代码中使用属性. 只读属性应该用 &#64;property 装饰器来创建.</p>
<p>如果子类没有覆盖属性, 那么属性的继承可能看上去不明显. 因此使用者必须确保访问方法间接被调用, 以保证子类中的重载方法被属性调用(使用模板方法设计模式).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">math</span>

     <span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
         <span class="sd">&quot;&quot;&quot;A square with two properties: a writable area and a read-only perimeter.</span>

<span class="sd">         To use:</span>
<span class="sd">         &gt;&gt;&gt; sq = Square(3)</span>
<span class="sd">         &gt;&gt;&gt; sq.area</span>
<span class="sd">         9</span>
<span class="sd">         &gt;&gt;&gt; sq.perimeter</span>
<span class="sd">         12</span>
<span class="sd">         &gt;&gt;&gt; sq.area = 16</span>
<span class="sd">         &gt;&gt;&gt; sq.side</span>
<span class="sd">         4</span>
<span class="sd">         &gt;&gt;&gt; sq.perimeter</span>
<span class="sd">         16</span>
<span class="sd">         &quot;&quot;&quot;</span>

         <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">=</span> <span class="n">side</span>

         <span class="k">def</span> <span class="nf">__get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Calculates the &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">**</span> <span class="mi">2</span>

         <span class="k">def</span> <span class="nf">___get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Indirect accessor for &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_area</span><span class="p">()</span>

         <span class="k">def</span> <span class="nf">__set_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Sets the &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

         <span class="k">def</span> <span class="nf">___set_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Indirect setter for &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_SetArea</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

         <span class="n">area</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">___get_area</span><span class="p">,</span> <span class="n">___set_area</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Gets or sets the area of the square.&quot;&quot;&quot;</span><span class="p">)</span>

         <span class="nd">@property</span>
         <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">*</span> <span class="mi">4</span>
</pre></div>
</div>
<p class="last">(译者注: 老实说, 我觉得这段示例代码很不恰当, 有必要这么蛋疼吗?)</p>
</dd>
</dl>
</div>
<div class="section" id="true-false">
<h6>True/False的求值</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能使用隐式false</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>Python在布尔上下文中会将某些值求值为false. 按简单的直觉来讲, 就是所有的&#8221;空&#8221;值都被认为是false. 因此0， None, [], {}, &#8220;&#8221; 都被认为是false.</dd>
<dt>优点:</dt>
<dd>使用Python布尔值的条件语句更易读也更不易犯错. 大部分情况下, 也更快.</dd>
<dt>缺点:</dt>
<dd>对C/C++开发人员来说, 可能看起来有点怪.</dd>
<dt>结论:</dt>
<dd><p class="first">尽可能使用隐式的false, 例如: 使用 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">foo:</span></tt> 而不是 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">foo</span> <span class="pre">!=</span> <span class="pre">[]:</span></tt> . 不过还是有一些注意事项需要你铭记在心:</p>
<ol class="last arabic">
<li><p class="first">永远不要用==或者!=来比较单件, 比如None. 使用is或者is not.</p>
</li>
<li><p class="first">注意: 当你写下 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">x:</span></tt> 时, 你其实表示的是 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></tt> . 例如: 当你要测试一个默认值是None的变量或参数是否被设为其它值. 这个值在布尔语义下可能是false!</p>
</li>
<li><p class="first">永远不要用==将一个布尔量与false相比较. 使用 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">x:</span></tt> 代替. 如果你需要区分false和None, 你应该用像 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">x</span> <span class="pre">and</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None:</span></tt> 这样的语句.</p>
</li>
<li><p class="first">对于序列(字符串, 列表, 元组), 要注意空序列是false. 因此 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">seq:</span></tt> 或者 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">seq:</span></tt> 比 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">len(seq):</span></tt> 或 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">len(seq):</span></tt> 要更好.</p>
</li>
<li><p class="first">处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">users</span><span class="p">:</span>
         <span class="k">print</span> <span class="s">&#39;no users&#39;</span>

     <span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_zero</span><span class="p">()</span>

     <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_multiple_of_ten</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="k">print</span> <span class="s">&#39;no users&#39;</span>

     <span class="k">if</span> <span class="n">foo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">foo</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_zero</span><span class="p">()</span>

     <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_multiple_of_ten</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">注意&#8216;0&#8217;(字符串)会被当做true.</p>
</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="id10">
<h6>过时的语言特性</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能使用字符串方法取代字符串模块. 使用函数调用语法取代apply(). 使用列表推导, for循环取代filter(), map()以及reduce().</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>当前版本的Python提供了大家通常更喜欢的替代品.</dd>
<dt>结论:</dt>
<dd><p class="first">我们不使用不支持这些特性的Python版本, 所以没理由不用新的方式.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="n">words</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">)</span>

     <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">,</span> <span class="n">my_list</span><span class="p">))</span>

     <span class="nb">apply</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">words</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)</span>

     <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_list</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">]</span>

     <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="scoping-lexical-scoping">
<h6>静态Scoping(Lexical Scoping)</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">推荐使用</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first">嵌套的Python函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 变量绑定的解析是使用静态Scoping, 也就是基于静态的程序文本. 对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量, 甚至是赋值前的处理. 如果碰到global声明, 该名称就会被视作全局变量.</p>
<p>一个使用这个特性的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_adder</span><span class="p">(</span><span class="n">summand1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a function that adds numbers to a given number.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">summand2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">summand1</span> <span class="o">+</span> <span class="n">summand2</span>

    <span class="k">return</span> <span class="n">adder</span>
</pre></div>
</div>
<p class="last">(译者注: 这个例子有点诡异, 你应该这样使用这个函数: <tt class="docutils literal"><span class="pre">sum</span> <span class="pre">=</span> <span class="pre">get_adder(summand1)(summand2)</span></tt> )</p>
</dd>
<dt>优点:</dt>
<dd>通常可以带来更加清晰, 优雅的代码. 尤其会让有经验的Lisp和Scheme(还有Haskell, ML等)程序员感到欣慰.</dd>
<dt>缺点:</dt>
<dd><p class="first">可能导致让人迷惑的bug. 例如下面这个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
    <span class="c"># ...</span>
    <span class="c"># A bunch of code here</span>
    <span class="c"># ...</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>  <span class="c"># Ah, i *is* local to Foo, so this is what Bar sees</span>
        <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
    <span class="n">bar</span><span class="p">()</span>
</pre></div>
</div>
<p>因此 <tt class="docutils literal"><span class="pre">foo([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></tt> 会打印 <tt class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">3</span></tt> , 不是 <tt class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span></tt> .</p>
<p class="last">(译者注: x是一个列表, for循环其实是将x中的值依次赋给i.这样对i的赋值就隐式的发生了, 整个foo函数体中的i都会被当做局部变量, 包括bar()中的那个. 这一点与C++之类的静态语言还是有很大差别的.)</p>
</dd>
<dt>结论:</dt>
<dd>鼓励使用.</dd>
</dl>
</div>
<div class="section" id="id11">
<h6>函数与方法装饰器</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果好处很显然, 就明智而谨慎的使用装饰器</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first">用于函数及方法的装饰器(也就是&#64;标记). 最常见的装饰器是&#64;classmethod 和&#64;staticmethod, 用于将常规函数转换成类方法或静态方法. 不过, 装饰器语法也允许用户自定义装饰器. 特别地, 对于某个函数 <tt class="docutils literal"><span class="pre">my_decorator</span></tt> , 下面的两段代码是等效的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="nd">@my_decorator</span>
   <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="c"># method body ...</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># method body ...</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>优点:</dt>
<dd>优雅的在函数上指定一些转换. 该转换可能减少一些重复代码, 保持已有函数不变(enforce invariants), 等.</dd>
<dt>缺点:</dt>
<dd>装饰器可以在函数的参数或返回值上执行任何操作, 这可能导致让人惊异的隐藏行为. 而且, 装饰器在导入时执行. 从装饰器代码的失败中恢复更加不可能.</dd>
<dt>结论:</dt>
<dd><p class="first">如果好处很显然, 就明智而谨慎的使用装饰器. 装饰器应该遵守和函数一样的导入和命名规则. 装饰器的python文档应该清晰的说明该函数是一个装饰器. 请为装饰器编写单元测试.</p>
<p>避免装饰器自身对外界的依赖(即不要依赖于文件, socket, 数据库连接等), 因为装饰器运行时这些资源可能不可用(例如导入时, 使用pychecker或其它工具时). 应该保证一个用有效参数调用的装饰器在所有情况下都是成功的.</p>
<p class="last">装饰器是一种特殊形式的&#8221;顶级代码&#8221;. 参考后面关于Main的话题.</p>
</dd>
</dl>
</div>
<div class="section" id="id12">
<h6>线程</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要依赖内建类型的原子性.</p>
</div>
<p>虽然Python的内建类型例如字典看上去拥有原子操作, 但是在某些情形下它们仍然不是原子的(即: 如果__hash__或__eq__被实现为Python方法)且它们的原子性是靠不住的. 你也不能指望原子变量赋值(因为这个反过来依赖字典).</p>
<p>优先使用Queue模块的 <tt class="docutils literal"><span class="pre">Queue</span></tt> 数据类型作为线程间的数据通信方式. 另外, 使用threading模块及其锁原语. 了解条件变量的合适使用方式, 这样你就可以使用 <tt class="docutils literal"><span class="pre">threading.Condition</span></tt> 来取代低级别的锁了.</p>
</div>
<div class="section" id="id13">
<h6>威力过大的特性</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">避免使用这些特性</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>Python是一种异常灵活的语言, 它为你提供了很多花哨的特性, 诸如元类(metaclasses), 字节码访问, 任意编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 导入黑客(import hacks), 反射, 系统内修改(modification of system internals), 等等.</dd>
<dt>优点:</dt>
<dd>强大的语言特性, 能让你的代码更紧凑.</dd>
<dt>缺点:</dt>
<dd>使用这些很&#8221;酷&#8221;的特性十分诱人, 但不是绝对必要. 使用奇技淫巧的代码将更加难以阅读和调试. 开始可能还好(对原作者而言), 但当你回顾代码, 它们可能会比那些稍长一点但是很直接的代码更加难以理解.</dd>
<dt>结论:</dt>
<dd>在你的代码中避免这些特性.</dd>
</dl>
</div>
</div>
<span id="document-google-python-styleguide/python_style_rules"></span><div class="section" id="python">
<h5>Python风格规范</h5>
<div class="section" id="id1">
<h6>分号</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
</div>
</div>
<div class="section" id="line-length">
<span id="id2"></span><h6>行长度</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每行不超过80个字符</p>
</div>
<p>例外: 如果使用Python 2.4或更早的版本, 导入模块的行可能多于80个字符.</p>
<p>Python会将圆括号, 中括号和花括号中的行隐式的连接起来, 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">foo_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">,</span> <span class="n">design</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">,</span>
             <span class="n">emphasis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">highlight</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
         <span class="n">color</span> <span class="o">==</span> <span class="s">&#39;red&#39;</span> <span class="ow">and</span> <span class="n">emphasis</span> <span class="o">==</span> <span class="s">&#39;strong&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;This will build a very long long &#39;</span>
     <span class="s">&#39;long long long long long long string&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>注意上面例子中的元素缩进; 你可以在本文的 <a class="reference internal" href="contents.html#indentation"><em>缩进</em></a> 部分找到解释.</p>
</div>
<div class="section" id="id3">
<h6>括号</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">宁缺毋滥的使用括号</p>
</div>
<p>除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="k">if</span> <span class="n">foo</span><span class="p">:</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">while</span> <span class="n">x</span><span class="p">:</span>
         <span class="n">x</span> <span class="o">=</span> <span class="n">bar</span><span class="p">()</span>
     <span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">:</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">return</span> <span class="n">foo</span>
     <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">):</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">return</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="indentation">
<span id="id4"></span><h6>缩进</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用4个空格来缩进代码</p>
</div>
<p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 <a class="reference internal" href="contents.html#line-length"><em>行长度</em></a> 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span>   <span class="c"># Aligned with opening delimiter</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span><span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span>
                                <span class="n">var_three</span><span class="p">,</span> <span class="n">var_four</span><span class="p">)</span>

       <span class="c"># 4-space hanging indent; nothing on first line</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span>
           <span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span> <span class="n">var_three</span><span class="p">,</span>
           <span class="n">var_four</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>    <span class="c"># Stuff on first line forbidden</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span><span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span>
           <span class="n">var_three</span><span class="p">,</span> <span class="n">var_four</span><span class="p">)</span>

       <span class="c"># 2-space hanging indent forbidden</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span>
         <span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span> <span class="n">var_three</span><span class="p">,</span>
         <span class="n">var_four</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h6>空行</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">顶级定义之间空两行, 方法定义之间空一行</p>
</div>
<p>顶级定义之间空两行, 比如函数或者类定义.  方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p>
</div>
<div class="section" id="id6">
<h6>空格</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">按照标准的排版规范来使用标点两边的空格</p>
</div>
<p>括号内不要有空格.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">spam</span><span class="p">(</span><span class="n">ham</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">{</span><span class="n">eggs</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">[])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="n">spam</span><span class="p">(</span> <span class="n">ham</span><span class="p">[</span> <span class="mi">1</span> <span class="p">],</span> <span class="p">{</span> <span class="n">eggs</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">[</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="k">print</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
     <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">:</span>
         <span class="k">print</span> <span class="n">x</span> <span class="p">,</span> <span class="n">y</span>
     <span class="n">x</span> <span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="p">,</span> <span class="n">x</span>
</pre></div>
</div>
<p>参数列表, 索引或切片的左括号前不应加空格.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">no</span><span class="p">:</span> <span class="n">spam</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="s">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="nb">dict</span> <span class="p">[</span><span class="s">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not).  至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="n">x</span><span class="o">&lt;</span><span class="mi">1</span>
</pre></div>
</div>
<p>当&#8217;=&#8217;用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="k">def</span> <span class="nf">complex</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span> <span class="k">return</span> <span class="n">magic</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">real</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">imag</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="k">def</span> <span class="nf">complex</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span> <span class="k">return</span> <span class="n">magic</span><span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">real</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">imag</span><span class="p">)</span>
</pre></div>
</div>
<p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span>
  <span class="n">foo</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c"># comment</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c"># comment that should not be aligned</span>

  <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s">&quot;foo&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="s">&quot;long_name&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>
  <span class="n">foo</span>       <span class="o">=</span> <span class="mi">1000</span>  <span class="c"># comment</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="mi">2</span>     <span class="c"># comment that should not be aligned</span>

  <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s">&quot;foo&quot;</span>      <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="s">&quot;long_name&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h6>Python解释器</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个模块都应该以#!/usr/bin/env python&lt;version&gt;开头</p>
</div>
<p>模块应该以一个构造行开始, 以指定执行这个程序用到的Python解释器:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python2.4</span>
</pre></div>
</div>
<p>总是使用最特化的版本, 例如, 使用/usr/bin/python2.4, 而不是 /usr/bin/python2. 这样, 当升级到不同的Python版本时, 能轻松找到依赖关系, 同时也避免了使用时的迷惑. 例如, /usr/bin/python2是表示/usr/bin/python2.0.1还是/usr/bin/python2.3.0?</p>
</div>
<div class="section" id="id8">
<h6>注释</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">确保对模块, 函数, 方法和行内注释使用正确的风格</p>
</div>
<p><strong>文档字符串</strong></p>
<blockquote>
<div>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号. 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述. 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</div></blockquote>
<p><strong>模块</strong></p>
<blockquote>
<div><p>每个文件应该包含下列项, 依次是:</p>
<ol class="arabic simple">
<li>版权声明(例如,  Copyright 2008 Google Inc.)</li>
<li>一个许可样板. 根据项目使用的许可(例如,  Apache 2.0, BSD, LGPL, GPL), 选择合适的样板</li>
<li>作者声明, 标识文件的原作者.</li>
</ol>
</div></blockquote>
<p><strong>函数和方法</strong></p>
<blockquote>
<div><p>如果不是既显然又简短, 任何函数或方法都需要一个文档字符串. 而且, 任何外部可访问的函数或方法, 不管多短多简单, 都需要文档字符串. 文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述&#8221;怎么做&#8221;, 除非是一些复杂的算法. 对于技巧性的代码, 块注释或者行内注释是最重要的. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 应该给参数单独写文档. 在冒号后跟上解释, 而且应该用统一的悬挂式2或4空格缩进. 文档字符串应该在需要特定类型的地方指定期望的类型.  &#8220;Raise:&#8221;部分应该列出该函数可能触发的所有异常. 生成器函数的文档字符串应该用&#8221;Yields:&#8221;而非&#8221;Returns:&#8221;.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">fetch_bigtable_rows</span><span class="p">(</span><span class="n">big_table</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">other_silly_variable</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fetches rows from a Bigtable.</span>

<span class="sd">    Retrieves rows pertaining to the given keys from the Table instance</span>
<span class="sd">    represented by big_table.  Silly things may happen if</span>
<span class="sd">    other_silly_variable is not None.</span>

<span class="sd">    Args:</span>
<span class="sd">        big_table: An open Bigtable Table instance.</span>
<span class="sd">        keys: A sequence of strings representing the key of each table row</span>
<span class="sd">            to fetch.</span>
<span class="sd">        other_silly_variable: Another optional variable, that has a much</span>
<span class="sd">            longer name than the other args, and which does nothing.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dict mapping keys to the corresponding table row data</span>
<span class="sd">        fetched. Each row is represented as a tuple of strings. For</span>
<span class="sd">        example:</span>

<span class="sd">        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),</span>
<span class="sd">         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),</span>
<span class="sd">         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}</span>

<span class="sd">        If a key from the keys argument is missing from the dictionary,</span>
<span class="sd">        then that row was not found in the table.</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: An error occurred accessing the bigtable.Table object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>类</strong></p>
<blockquote>
<div><p>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SampleClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary of class here.</span>

<span class="sd">    Longer class information....</span>
<span class="sd">    Longer class information....</span>

<span class="sd">    Attributes:</span>
<span class="sd">        likes_spam: A boolean indicating if we like SPAM or not.</span>
<span class="sd">        eggs: An integer count of the eggs we have laid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likes_spam</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likes_spam</span> <span class="o">=</span> <span class="n">likes_spam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eggs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">public_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>块注释和行注释</strong></p>
<blockquote>
<div><p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次代码走查的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># We use a weighted dictionary search to find out where i is in</span>
<span class="c"># the array.  We extrapolate position based on the largest num</span>
<span class="c"># in the array and the array size and then do binary search to</span>
<span class="c"># get the exact number.</span>

<span class="k">if</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>        <span class="c"># true iff i is a power of 2</span>
</pre></div>
</div>
<p>为了提高可读性, 注释应该至少离开代码2个空格.</p>
<p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span>
<span class="c"># the next element is i+1</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id9">
<h6>类</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span> <span class="k">class</span> <span class="nc">SampleClass</span><span class="p">:</span>
        <span class="k">pass</span>


    <span class="k">class</span> <span class="nc">OuterClass</span><span class="p">:</span>

        <span class="k">class</span> <span class="nc">InnerClass</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="k">class</span> <span class="nc">SampleClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
         <span class="k">pass</span>


     <span class="k">class</span> <span class="nc">OuterClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

         <span class="k">class</span> <span class="nc">InnerClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
             <span class="k">pass</span>


     <span class="k">class</span> <span class="nc">ChildClass</span><span class="p">(</span><span class="n">ParentClass</span><span class="p">):</span>
         <span class="sd">&quot;&quot;&quot;Explicitly inherits from another class already.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>继承自 <tt class="docutils literal"><span class="pre">object</span></tt> 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受Python 3000的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 <tt class="docutils literal"><span class="pre">__new__,</span> <span class="pre">__init__,</span> <span class="pre">__delattr__,</span> <span class="pre">__getattribute__,</span> <span class="pre">__setattr__,</span> <span class="pre">__hash__,</span> <span class="pre">__repr__,</span> <span class="pre">and</span> <span class="pre">__str__</span></tt> .</p>
</div>
<div class="section" id="id10">
<h6>字符串</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用%操作符格式化字符串, 即使参数都是字符串. 不过也不能一概而论, 你需要在+和%之间好好判定.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c"># use + in this case</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">imperative</span> <span class="o">+</span> <span class="s">&#39;, &#39;</span> <span class="o">+</span> <span class="n">expletive</span> <span class="o">+</span> <span class="s">&#39;!&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;name: &#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#39;; score: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
     <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">imperative</span><span class="p">,</span> <span class="n">expletive</span><span class="p">)</span>
     <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;name: </span><span class="si">%s</span><span class="s">; score: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <tt class="docutils literal"><span class="pre">.join</span></tt> 连接列表. (也可以将每个子串写入一个 <tt class="docutils literal"><span class="pre">cStringIO.StringIO</span></tt> 缓存中.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span> <span class="n">employee_table</span> <span class="o">=</span> <span class="s">&#39;&lt;table&gt;&#39;</span>
    <span class="k">for</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span> <span class="ow">in</span> <span class="n">employee_list</span><span class="p">:</span>
        <span class="n">employee_table</span> <span class="o">+=</span> <span class="s">&#39;&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span><span class="p">)</span>
    <span class="n">employee_table</span> <span class="o">+=</span> <span class="s">&#39;&lt;/table&gt;&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&lt;table&gt;&#39;</span><span class="p">]</span>
     <span class="k">for</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span> <span class="ow">in</span> <span class="n">employee_list</span><span class="p">:</span>
         <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span><span class="p">))</span>
     <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;&lt;/table&gt;&#39;</span><span class="p">)</span>
     <span class="n">employee_table</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
</pre></div>
</div>
<p>为多行字符串使用三重双引号而非三重单引号. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;&quot;&quot;This is pretty ugly.</span>
<span class="s">Don&#39;t do this.</span>
<span class="s">&quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span>
  <span class="k">print</span> <span class="p">(</span><span class="s">&quot;This is much nicer.</span><span class="se">\n</span><span class="s">&quot;</span>
         <span class="s">&quot;Do it this way.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="todo">
<h6>TODO注释</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p>
</div>
<p>TODO注释应该在所有开头处包含&#8221;TODO&#8221;字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># TODO(kl@gmail.com): Drop the use of &quot;has_key&quot;.</span>
<span class="c"># TODO(Zeke) change this to use relations.</span>
</pre></div>
</div>
<p>如果你的TODO是&#8221;将来做某事&#8221;的形式, 那么请确保你包含了一个指定的日期(&#8220;2009年11月解决&#8221;)或者一个特定的事件(&#8220;等到所有的客户都可以处理XML请求就移除这些代码&#8221;).</p>
</div>
<div class="section" id="id11">
<h6>导入格式</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个导入应该独占一行</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">os</span>
     <span class="kn">import</span> <span class="nn">sys</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>  <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
</pre></div>
</div>
<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前.  导入应该按照从最通用到最不通用的顺序分组:</p>
<ol class="arabic simple">
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入</li>
</ol>
<p>每种分组中,  应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">foo</span>
<span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">bar</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="kn">import</span> <span class="n">baz</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="kn">import</span> <span class="n">Quux</span>
<span class="kn">from</span> <span class="nn">Foob</span> <span class="kn">import</span> <span class="n">ar</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h6>语句</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">通常每个语句应该独占一行</p>
</div>
<p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行.  如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 <tt class="docutils literal"><span class="pre">try/except</span></tt> 这样做, 因为try和except不能放在同一行.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Yes</span><span class="p">:</span>

  <span class="k">if</span> <span class="n">foo</span><span class="p">:</span> <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">No</span><span class="p">:</span>

  <span class="k">if</span> <span class="n">foo</span><span class="p">:</span> <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>   <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>               <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
      <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h6>访问控制</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p>
<p class="last">(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)</p>
</div>
<p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 <tt class="docutils literal"><span class="pre">get_foo()</span></tt> 和 <tt class="docutils literal"><span class="pre">set_foo()</span></tt> 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p>
</div>
<div class="section" id="id14">
<h6>命名</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.</p>
</div>
<p><strong>应该避免的名称</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>单字符名称, 除了计数器和迭代器.</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如__init__)</li>
</ol>
</div></blockquote>
<p><strong>命名约定</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>所谓&#8221;内部(Internal)&#8221;表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含).</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有.</li>
<li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li>
<li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li>
</ol>
</div></blockquote>
<p><strong>Python之父Guido推荐的规范</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="17%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Public</th>
<th class="head">Internal</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Modules</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr class="row-odd"><td>Packages</td>
<td>lower_with_under</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Classes</td>
<td>CapWords</td>
<td>_CapWords</td>
</tr>
<tr class="row-odd"><td>Exceptions</td>
<td>CapWords</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Functions</td>
<td>lower_with_under()</td>
<td>_lower_with_under()</td>
</tr>
<tr class="row-odd"><td>Global/Class Constants</td>
<td>CAPS_WITH_UNDER</td>
<td>_CAPS_WITH_UNDER</td>
</tr>
<tr class="row-even"><td>Global/Class Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr class="row-odd"><td>Instance Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr class="row-even"><td>Method Names</td>
<td>lower_with_under()</td>
<td>_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr class="row-odd"><td>Function/Method Parameters</td>
<td>lower_with_under</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Local Variables</td>
<td>lower_with_under</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="main">
<h6>Main</h6>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p>
</div>
<p>在Python中, pychecker, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></tt> , 这样当模块被导入时主程序就不会被执行.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
      <span class="o">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pychecker或pydoc时执行的操作.</p>
</div>
</div>
<span id="document-google-python-styleguide/parting_words"></span><div class="section" id="id1">
<h5>临别赠言</h5>
<p><strong>请务必保持代码的一致性</strong></p>
<p>如果你正在编辑代码, 花几分钟看一下周边代码, 然后决定风格. 如果它们在所有的算术操作符两边都使用空格, 那么你也应该这样做. 如果它们的注释都用标记包围起来, 那么你的注释也要这样.</p>
<p>制定风格指南的目的在于让代码有规可循, 这样人们就可以专注于&#8221;你在说什么&#8221;, 而不是&#8221;你在怎么说&#8221;. 我们在这里给出的是全局的规范, 但是本地的规范同样重要. 如果你加到一个文件里的代码和原有代码大相径庭, 它会让读者不知所措. 避免这种情况.</p>
<div class="line-block">
<div class="line">Revision 2.19</div>
<div class="line"><br /></div>
<div class="line">Amit Patel</div>
<div class="line">Antoine Picard</div>
<div class="line">Eugene Jhong</div>
<div class="line">Jeremy Hylton</div>
<div class="line">Matt Smart</div>
<div class="line">Mike Shields</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="contents.html#document-contents">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>